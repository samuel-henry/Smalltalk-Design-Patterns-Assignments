Object subclass: #Filter	instanceVariableNames: 'output'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!Filter commentStamp: 'sjh 5/7/2013 08:51' prior: 0!Abstract superclass!!Filter methodsFor: 'filtering' stamp: 'sjh 5/29/2013 14:56'!pullFrom: aPipe	"this should be implemented by concrete filters"	^ self subclassResponsibility! !!Filter methodsFor: 'filtering' stamp: 'sjh 5/29/2013 14:57'!push: someData to: aPipe	"push some data to the tail of a pipe" 	aPipe add: someData.! !!Filter methodsFor: 'as yet unclassified' stamp: 'sjh 5/31/2013 17:12'!update: anAspectSymbol 	"sent when parents (objects this instance is dependent on) change state"	self pullFrom: anAspectSymbol.! !!Filter methodsFor: 'accessing' stamp: 'sjh 6/1/2013 13:49'!output		^ output ifNil:[output := Dictionary new]! !Filter subclass: #CustomerNotifierFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!CustomerNotifierFilter commentStamp: 'sjh 5/29/2013 16:15' prior: 0!Notify customers of order status!!CustomerNotifierFilter methodsFor: 'as yet unclassified' stamp: 'sjh 6/2/2013 14:23'!pullFrom: aPipe	| input order message file |	aPipe isEmpty		ifFalse: [input := aPipe removeFirst.				order := input at: 'order'.				message := input at: 'message'.	 			file := FileDirectory default forceNewFileNamed: (Date today asString, String space, Time now print24). 				file nextPutAll: message, String cr, order.				file close. ].! !Object subclass: #InventoryManager	instanceVariableNames: 'location inventory'	classVariableNames: 'UniqueInstance'	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!InventoryManager methodsFor: 'initialize-release' stamp: 'sjh 5/30/2013 01:38'!initializeInventory	"create a dictionary of items and quantities"	inventory := Dictionary new. 	inventory at: 'SAM-56323' put: 5; at: 'SAM-76232' put: 10; at: 'SAM-23782' put: 7; at: 'SAM-48840' put: 93; at: 'SAM-22661' put: 13; at: 'SAM-45490' put: 22; at: 'SAM-33820' put: 64; at: 'SAM-88227' put: 2; at: 'SAM-33800' put: 17; at: 'SAM-99287' put: 22; at: 'SAM-42839' put: 1; at: 'SAM-57572' put: 33; at: 'SAM-48204' put: 5; at: 'SAM-50824' put: 3; at: 'SAM-24923' put: 0; at: 'SAM-37378' put: 4; at: 'SAM-09131' put: 2; at: 'SAM-47472' put: 25; at: 'SAM-34310' put: 54; at: 'SAM-59527' put: 10; at: 'SAM-46103' put: 5.! !!InventoryManager methodsFor: 'stockkeeping' stamp: 'sjh 6/1/2013 14:18'!checkOrderItemsInStock: anOrder	| leftover placeable aSku |	placeable := true.		"iterate over each item in the order. calculate the amount left after the desired order amount. if there is enough in stock (leftover >= 0), deplete the inventory by the desired amount, otherwise restock and specify that the order is not placeable due to insufficient stock of at least one item"	anOrder items associationsDo: [ :assoc | aSku := assoc key.						  leftover := (inventory at: aSku) - (assoc value).						  leftover < 0 							ifTrue: [ self replenish: aSku from: (leftover * -1).									 placeable := false. ]							ifFalse: [ inventory at: aSku put: leftover ] ].	^ placeable! !!InventoryManager methodsFor: 'stockkeeping' stamp: 'sjh 5/30/2013 01:34'!replenish: aSku from: overage	"replenish our stock of this item by adding an additonal amount of inventory equal to twice the shortcoming"	inventory at: aSku put: ((inventory at: aSku) + overage *2)! !!InventoryManager methodsFor: 'accessing' stamp: 'sjh 5/30/2013 01:22'!inventory	^ inventory! !!InventoryManager methodsFor: 'accessing' stamp: 'sjh 5/30/2013 01:22'!inventory: anObject	inventory := anObject! !!InventoryManager methodsFor: 'accessing' stamp: 'sjh 5/29/2013 15:55'!location	^ Point x: 51 y: 50! !!InventoryManager methodsFor: 'accessing' stamp: 'sjh 5/29/2013 15:49'!location: anObject	location := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!InventoryManager class	instanceVariableNames: ''!!InventoryManager class methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:05'!getInstance	"return the Singleton instance of InventoryManager"	UniqueInstance isNil		ifTrue: [UniqueInstance := self basicNew initializeInventory ].	^UniqueInstance! !!InventoryManager class methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:05'!new	"override new to return an error if anyone tries to instantiate InventoryManager without calling getInstance"	self error: 'You may not instantiate InventoryManager using the new message. Use the getInstance message to get the singleton instance of InventoryManager'! !!InventoryManager class methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:05'!reset	UniqueInstance := nil.! !Filter subclass: #LoggerFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!LoggerFilter commentStamp: 'sjh 5/29/2013 16:15' prior: 0!Write orders to file!!LoggerFilter methodsFor: 'as yet unclassified' stamp: 'sjh 6/2/2013 14:20'!pullFrom: aPipe	| anOrder file |	aPipe isEmpty		ifFalse: [anOrder := aPipe removeFirst.				file := FileDirectory default oldFileNamed: 'SAM-Orders'. 				file setToEnd nextPutAll: anOrder printString; cr; close ].							! !Object subclass: #Order	instanceVariableNames: 'items location contactAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!Order methodsFor: 'as yet unclassified' stamp: 'sjh 6/1/2013 13:16'!accept: aVisitor	^ self subclassResponsibility! !!Order methodsFor: 'as yet unclassified' stamp: 'sjh 5/31/2013 17:32'!contactAddress: anAddress items: someItems location: aLocation	contactAddress := anAddress.	items := someItems.	location := aLocation.! !!Order methodsFor: 'as yet unclassified' stamp: 'sjh 6/2/2013 14:26'!printString	| printableOrder |	printableOrder := contactAddress, String tab, location.	items associationsDo: [ :assoc | printableOrder := printableOrder, String tab, assoc key, String tab, assoc value asString ].	^ printableOrder! !!Order methodsFor: 'accessing' stamp: 'sjh 5/29/2013 16:25'!contactAddress	^ contactAddress! !!Order methodsFor: 'accessing' stamp: 'sjh 5/29/2013 16:25'!contactAddress: anObject	contactAddress := anObject! !!Order methodsFor: 'accessing' stamp: 'sjh 5/29/2013 16:25'!items	^ items! !!Order methodsFor: 'accessing' stamp: 'sjh 5/29/2013 16:25'!items: anObject	items := anObject! !!Order methodsFor: 'accessing' stamp: 'sjh 6/1/2013 13:16'!location	^ location! !!Order methodsFor: 'accessing' stamp: 'sjh 5/29/2013 15:57'!location: anObject	location := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Order class	instanceVariableNames: ''!!Order class methodsFor: 'as yet unclassified' stamp: 'sjh 5/31/2013 17:32'!contactAddress: anAddress items: someItems location: aLocation	^ self basicNew contactAddress: anAddress items: someItems location: aLocation! !!Order class methodsFor: 'as yet unclassified' stamp: 'sjh 6/1/2013 13:57'!getOrder: aRawOrder	"get a concrete order representing the passed in parameters. this is a modified implementation of http://stackoverflow.com/questions/3121102/smalltalk-equivalent-of-a-factory-method"	| matchingClass shippingMethod |		shippingMethod := aRawOrder at: 'shippingMethod'.	matchingClass := self subclasses detect: [ :first | first matching: shippingMethod ].	matchingClass isNil		ifTrue: [ ^self error: 'Unsupported shipping method' ]		ifFalse: [ ^matchingClass contactAddress: (aRawOrder at: 'contactAddress') items: (aRawOrder at: 'items') location: (aRawOrder at: 'location') ].! !!Order class methodsFor: 'as yet unclassified' stamp: 'sjh 6/1/2013 14:00'!matching: anObject	^self subclassResponsibility! !Order subclass: #OneDayOrder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!OneDayOrder methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:15'!accept: aVisitor	^ aVisitor visitOneDay: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneDayOrder class	instanceVariableNames: ''!!OneDayOrder class methodsFor: 'as yet unclassified' stamp: 'sjh 6/1/2013 14:00'!matching: anObject	^ anObject = 1! !Filter subclass: #OrderAccepterFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!OrderAccepterFilter commentStamp: 'sjh 5/29/2013 16:10' prior: 0!Take in a Dictionary representation of an order, pass it to the OrderFactory to get a concrete Order, then pipe this Order towards the PlaceabilityFilter!!OrderAccepterFilter methodsFor: 'as yet unclassified' stamp: 'sjh 6/2/2013 13:48'!pullFrom: aPipe	aPipe isEmpty		ifFalse: [ self push: (Order getOrder: (aPipe removeFirst)) to: (self output at: 'placability') ].! !Filter subclass: #OrderCreatorFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!OrderCreatorFilter methodsFor: 'as yet unclassified' stamp: 'sjh 6/2/2013 14:01'!pullFrom: aPipe	| anOrder |	"if the pipe is not empty, get the most recent order data"	aPipe isEmpty		ifFalse: [anOrder := aPipe removeFirst.				"visit the order to attach a priority, then add it it to the PickQueue"				PickQueue new addMsg: (PickMessage new yourself payload: (anOrder accept: PrepareForPickVisitor new)).					"put the order in the logger filter to store the transaction"				self push: anOrder to: (output at: 'logger'). 								"put the order in the notifier filter to inform the customer"				 self push: ((Dictionary new) at: 'message' put: (OrderCreatorFilter placedOrderMessage); at: 'order' put: anOrder; yourself) to: (output at: 'notifier')].		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OrderCreatorFilter class	instanceVariableNames: ''!!OrderCreatorFilter class methodsFor: 'as yet unclassified' stamp: 'sjh 6/2/2013 13:18'!placedOrderMessage	^'Your order has been placed'! !Object subclass: #OrderFactory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!OrderFactory commentStamp: 'sjh 5/30/2013 02:17' prior: 0!gets the proper Order subclass - TODO: is this necessary? can we do it with the metaclass?!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OrderFactory class	instanceVariableNames: ''!!OrderFactory class methodsFor: 'as yet unclassified' stamp: 'sjh 5/31/2013 18:40'!getOrder: aRawOrder	"get items, location, contactAddress, shipping method"		"***SEE http://stackoverflow.com/questions/3121102/smalltalk-equivalent-of-a-factory-method for Smalltalk Factory***"		| shippingMethod contactAddress items location |		shippingMethod := aRawOrder at: 'shippingMethod'.	contactAddress := aRawOrder at: 'contactAddress'.	items := aRawOrder at: 'items'.	location := aRawOrder at: 'location'.		shippingMethod isNil | shippingMethod = 7		ifTrue: [ ^SevenDayOrder contactAddress: contactAddress items: items location: location ]		ifFalse: [ shippingMethod = 1					ifTrue: [ ^OneDayOrder contactAddress: contactAddress items: items location: location ]					ifFalse: [ shippingMethod = 3								ifTrue: [ ^ThreeDayOrder contactAddress: contactAddress items: items location: location ]								ifFalse: [ ^ self error: 'Unsupported delivery method' ].							].				].! !Filter subclass: #OrderPlacabilityFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!OrderPlacabilityFilter commentStamp: 'sjh 5/29/2013 15:38' prior: 0!Determine order placability in terms of the concrete order type, thecustomer's distance from the warehouse/days in transit, and the inventory status for each line item.!!OrderPlacabilityFilter methodsFor: 'as yet unclassified' stamp: 'sjh 6/2/2013 14:17'!pullFrom: aPipe	| anOrder |	"if the pipe is not empty, get the most recent order"	aPipe isEmpty		ifFalse: [anOrder := aPipe removeFirst].		"visit the order to get placeability"	(anOrder accept: PlacabilityVisitor new)		ifTrue: [ self push: anOrder to: (output at: 'creator')  ]		ifFalse: [ self push: ((Dictionary new) at: 'message' put: (OrderPlacabilityFilter unplacableMessage); at: 'order' put: anOrder; yourself) to: (output at: 'notifier') ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OrderPlacabilityFilter class	instanceVariableNames: ''!!OrderPlacabilityFilter class methodsFor: 'as yet unclassified' stamp: 'sjh 6/1/2013 14:40'!unplacableMessage	^ 'Your order cannot be placed at this time'! !Object subclass: #PickMessage	instanceVariableNames: 'payload'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!PickMessage methodsFor: 'accessing' stamp: 'sjh 5/29/2013 14:59'!payload	^ payload! !!PickMessage methodsFor: 'accessing' stamp: 'sjh 5/29/2013 14:59'!payload: anObject	payload := anObject! !OrderedCollection subclass: #PickQueue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!PickQueue methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 14:58'!addMsg: aMessage	"add a message to the tail of the queue"	super add: aMessage! !!PickQueue methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 14:58'!peek	"retrieve but do not remove the head of the queue"	^ super last! !!PickQueue methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 14:58'!popMsg	"remove the head of the queue"	^ super removeLast! !OrderedCollection subclass: #Pipe	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!Pipe commentStamp: 'sjh 5/7/2013 09:11' prior: 0!OrderedCollection already implements everything we need so far for a pipe!!Pipe methodsFor: 'as yet unclassified' stamp: 'sjh 6/1/2013 14:44'!add: anObject	"add this object to our pipe"	super addLast: anObject.		"notify dependents"	self changed: self.! !Order subclass: #SevenDayOrder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!SevenDayOrder methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:15'!accept: aVisitor	^ aVisitor visitSevenDay: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SevenDayOrder class	instanceVariableNames: ''!!SevenDayOrder class methodsFor: 'as yet unclassified' stamp: 'sjh 6/1/2013 14:01'!matching: anObject	^anObject = 7! !Order subclass: #ThreeDayOrder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!ThreeDayOrder methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:15'!accept: aVisitor	^ aVisitor visitThreeDay: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ThreeDayOrder class	instanceVariableNames: ''!!ThreeDayOrder class methodsFor: 'as yet unclassified' stamp: 'sjh 6/1/2013 14:04'!matching: anObject	^anObject = 3! !Object subclass: #Visitor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!Visitor methodsFor: 'visitation' stamp: 'sjh 5/29/2013 15:12'!visitOneDay: aOneDayOrder	^ self subclassResponsibility! !!Visitor methodsFor: 'visitation' stamp: 'sjh 5/29/2013 15:13'!visitSevenDay: aSevenDayOrder	^ self subclassResponsibility! !!Visitor methodsFor: 'visitation' stamp: 'sjh 5/29/2013 15:13'!visitThreeDay: aThreeDayOrder	^ self subclassResponsibility! !Visitor subclass: #PlacabilityVisitor	instanceVariableNames: 'speed'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!PlacabilityVisitor methodsFor: 'as yet unclassified' stamp: 'sjh 6/2/2013 15:02'!speed	^ 50! !!PlacabilityVisitor methodsFor: 'as yet unclassified' stamp: 'sjh 6/2/2013 15:01'!visitOneDay: aOneDayOrder	| distance |	(InventoryManager getInstance checkOrderItemsInStock: aOneDayOrder)		ifTrue: [ distance := aOneDayOrder location dist: (InventoryManager getInstance location).				 ^ distance <= self speed ]		ifFalse: [ ^ false ].! !!PlacabilityVisitor methodsFor: 'as yet unclassified' stamp: 'sjh 6/2/2013 15:01'!visitSevenDay: aSevenDayOrder	| distance |	(InventoryManager getInstance checkOrderItemsInStock: aSevenDayOrder)		ifTrue: [ distance := aSevenDayOrder location dist: (InventoryManager getInstance location).				 ^ (distance / 7) <= self speed ]		ifFalse: [ ^ false ].! !!PlacabilityVisitor methodsFor: 'as yet unclassified' stamp: 'sjh 6/2/2013 15:01'!visitThreeDay: aThreeDayOrder	| distance |		(InventoryManager getInstance checkOrderItemsInStock: aThreeDayOrder)		ifTrue: [ distance := aThreeDayOrder location dist: (InventoryManager getInstance location).				 ^ (distance / 3) <= self speed ]		ifFalse: [ ^ false ].! !Visitor subclass: #PrepareForPickVisitor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!PrepareForPickVisitor commentStamp: 'sjh 5/29/2013 15:31' prior: 0!Associate a priority with an Order!!PrepareForPickVisitor methodsFor: 'visitation' stamp: 'sjh 6/1/2013 15:00'!visitOneDay: aOneDayOrder	^ Dictionary new yourself at: 'priority' put: 1; at: 'order' put: aOneDayOrder! !!PrepareForPickVisitor methodsFor: 'visitation' stamp: 'sjh 6/1/2013 15:02'!visitSevenDay: aSevenDayOrder	^ Dictionary new yourself at: 1 put: 7; at: 2 put: aSevenDayOrder! !!PrepareForPickVisitor methodsFor: 'visitation' stamp: 'sjh 6/1/2013 15:02'!visitThreeDay: aThreeDayOrder	^ Dictionary new yourself at: 1 put: 3; at: 2 put: aThreeDayOrder! !