Object subclass: #Filter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!Filter commentStamp: 'sjh 5/7/2013 08:51' prior: 0!Abstract superclass!!Filter methodsFor: 'filtering' stamp: 'sjh 5/29/2013 14:56'!pullFrom: aPipe	"this should be implemented by concrete filters"	^ self subclassResponsibility! !!Filter methodsFor: 'filtering' stamp: 'sjh 5/29/2013 14:57'!push: someData to: aPipe	"push some data to the tail of a pipe" 	aPipe add: someData.! !Filter subclass: #CustomerNotifierFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!CustomerNotifierFilter commentStamp: 'sjh 5/29/2013 16:15' prior: 0!Notify customers of order status!Object subclass: #InventoryManager	instanceVariableNames: 'location inventory'	classVariableNames: 'UniqueInstance'	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!InventoryManager methodsFor: 'initialize-release' stamp: 'sjh 5/30/2013 01:38'!initializeInventory	"create a dictionary of items and quantities"	inventory := Dictionary new. 	inventory at: 'SAM-56323' put: 5; at: 'SAM-76232' put: 10; at: 'SAM-23782' put: 7; at: 'SAM-48840' put: 93; at: 'SAM-22661' put: 13; at: 'SAM-45490' put: 22; at: 'SAM-33820' put: 64; at: 'SAM-88227' put: 2; at: 'SAM-33800' put: 17; at: 'SAM-99287' put: 22; at: 'SAM-42839' put: 1; at: 'SAM-57572' put: 33; at: 'SAM-48204' put: 5; at: 'SAM-50824' put: 3; at: 'SAM-24923' put: 0; at: 'SAM-37378' put: 4; at: 'SAM-09131' put: 2; at: 'SAM-47472' put: 25; at: 'SAM-34310' put: 54; at: 'SAM-59527' put: 10; at: 'SAM-46103' put: 5.! !!InventoryManager methodsFor: 'stockkeeping' stamp: 'sjh 5/30/2013 02:04'!checkOrderItemsInStock: anOrder	| leftover placeable aSku |	placeable := true.		"iterate over each item in the order. calculate the amount left after the desired order amount. if there is enough in stock (leftover >= 0), deplete the inventory by the desired amount, otherwise restock and specify that the order is not placeable due to insufficient stock of at least one item"	anOrder items do: [ :each | aSku := each at: 1.						  leftover := (inventory at: aSku) - (each at: 2).						  leftover < 0 							ifTrue: [ self replenish: aSku from: (leftover * -1).									 placeable := false. ]							ifFalse: [ inventory at: aSku put: leftover ] ].	^ placeable! !!InventoryManager methodsFor: 'stockkeeping' stamp: 'sjh 5/30/2013 01:34'!replenish: aSku from: overage	"replenish our stock of this item by adding an additonal amount of inventory equal to twice the shortcoming"	inventory at: aSku put: ((inventory at: aSku) + overage *2)! !!InventoryManager methodsFor: 'accessing' stamp: 'sjh 5/30/2013 01:22'!inventory	^ inventory! !!InventoryManager methodsFor: 'accessing' stamp: 'sjh 5/30/2013 01:22'!inventory: anObject	inventory := anObject! !!InventoryManager methodsFor: 'accessing' stamp: 'sjh 5/29/2013 15:55'!location	^ Point x: 51 y: 50! !!InventoryManager methodsFor: 'accessing' stamp: 'sjh 5/29/2013 15:49'!location: anObject	location := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!InventoryManager class	instanceVariableNames: ''!!InventoryManager class methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:05'!getInstance	"return the Singleton instance of InventoryManager"	UniqueInstance isNil		ifTrue: [UniqueInstance := self basicNew initializeInventory ].	^UniqueInstance! !!InventoryManager class methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:05'!new	"override new to return an error if anyone tries to instantiate InventoryManager without calling getInstance"	self error: 'You may not instantiate InventoryManager using the new message. Use the getInstance message to get the singleton instance of InventoryManager'! !!InventoryManager class methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:05'!reset	UniqueInstance := nil.! !Filter subclass: #LoggerFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!LoggerFilter commentStamp: 'sjh 5/29/2013 16:15' prior: 0!Write orders to file!Object subclass: #Order	instanceVariableNames: 'items location contactAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!Order methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:15'!accept: aVisitor	^ self subclassResponsibility! !!Order methodsFor: 'accessing' stamp: 'sjh 5/29/2013 16:25'!contactAddress	^ contactAddress! !!Order methodsFor: 'accessing' stamp: 'sjh 5/29/2013 16:25'!contactAddress: anObject	contactAddress := anObject! !!Order methodsFor: 'accessing' stamp: 'sjh 5/29/2013 16:25'!items	^ items! !!Order methodsFor: 'accessing' stamp: 'sjh 5/29/2013 16:25'!items: anObject	items := anObject! !!Order methodsFor: 'accessing' stamp: 'sjh 5/29/2013 15:57'!location	^ location! !!Order methodsFor: 'accessing' stamp: 'sjh 5/29/2013 15:57'!location: anObject	location := anObject! !Order subclass: #OneDayOrder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!OneDayOrder methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:15'!accept: aVisitor	^ aVisitor visitOneDay: self! !Filter subclass: #OrderAccepterFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!OrderAccepterFilter commentStamp: 'sjh 5/29/2013 16:10' prior: 0!Take in a Dictionary representation of an order, pass it to the OrderFactory to get a concrete Order, then pipe this Order towards the PlaceabilityFilter!!OrderAccepterFilter methodsFor: 'as yet unclassified' stamp: 'sjh 5/30/2013 02:07'!pullFrom: aPipe	| aRawOrder |	"if the pipe is not empty, get the most recent order"	aPipe isEmpty		ifFalse: [aRawOrder := aPipe removeFirst ].			OrderFactory getOrder: aRawOrder.! !Filter subclass: #OrderCreatorFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!OrderCreatorFilter methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:39'!pullFrom: aPipe	| myData |	"if the pipe is not empty, get the most recent order"	aPipe isEmpty		ifFalse: [myData := aPipe removeFirst asUppercase].		"visit the order to attach a priority, then add it it to the PickQueue"	PickQueue new addMsg: (PickMessage new; payload: (myData accept: PrepareForPickVisitor new)).		"put the order in the logger filter to store the transaction"! !Object subclass: #OrderFactory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!OrderFactory commentStamp: 'sjh 5/30/2013 02:17' prior: 0!gets the proper Order subclass - TODO: is this necessary? can we do it with the metaclass?!!OrderFactory methodsFor: 'as yet unclassified' stamp: 'sjh 5/30/2013 02:17'!getOrder: aRawOrder	"get items, location, contactAddress, shipping method"	! !Filter subclass: #OrderPlacabilityFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!OrderPlacabilityFilter commentStamp: 'sjh 5/29/2013 15:38' prior: 0!Determine order placability in terms of the concrete order type, thecustomer's distance from the warehouse/days in transit, and the inventory status for each line item.!!OrderPlacabilityFilter methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:43'!pullFrom: aPipe	| myData |	"if the pipe is not empty, get the most recent order"	aPipe isEmpty		ifFalse: [myData := aPipe removeFirst].		"visit the order to get placeability"	(myData accept: PlaceabilityVisitor new)		ifTrue: [ "pipe to OrderCreatorFilter" ]		ifFalse: [ "pipe to OrderLoggerFilter" ].! !Object subclass: #PickMessage	instanceVariableNames: 'payload'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!PickMessage methodsFor: 'accessing' stamp: 'sjh 5/29/2013 14:59'!payload	^ payload! !!PickMessage methodsFor: 'accessing' stamp: 'sjh 5/29/2013 14:59'!payload: anObject	payload := anObject! !OrderedCollection subclass: #PickQueue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!PickQueue methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 14:58'!addMsg: aMessage	"add a message to the tail of the queue"	super add: aMessage! !!PickQueue methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 14:58'!peek	"retrieve but do not remove the head of the queue"	^ super last! !!PickQueue methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 14:58'!popMsg	"remove the head of the queue"	^ super removeLast! !OrderedCollection subclass: #Pipe	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!Pipe commentStamp: 'sjh 5/7/2013 09:11' prior: 0!OrderedCollection already implements everything we need so far for a pipe!Order subclass: #SevenDayOrder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!SevenDayOrder methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:15'!accept: aVisitor	^ aVisitor visitSevenDay: self! !Order subclass: #ThreeDayOrder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!ThreeDayOrder methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:15'!accept: aVisitor	^ aVisitor visitThreeDay: self! !Object subclass: #Visitor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!Visitor methodsFor: 'visitation' stamp: 'sjh 5/29/2013 15:12'!visitOneDay: aOneDayOrder	^ self subclassResponsibility! !!Visitor methodsFor: 'visitation' stamp: 'sjh 5/29/2013 15:13'!visitSevenDay: aSevenDayOrder	^ self subclassResponsibility! !!Visitor methodsFor: 'visitation' stamp: 'sjh 5/29/2013 15:13'!visitThreeDay: aThreeDayOrder	^ self subclassResponsibility! !Visitor subclass: #PlaceabilityVisitor	instanceVariableNames: 'speed'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!PlaceabilityVisitor methodsFor: 'visitation' stamp: 'sjh 5/29/2013 16:01'!visitOneDay: aOneDayOrder	| distance |	(InventoryManager getInstance orderItemsInStock: aOneDayOrder)		ifTrue: [ distance := aOneDayOrder location dist: (InventoryManager getInstance location).				 ^ distance > speed ]		ifFalse: [ ^ false ].! !!PlaceabilityVisitor methodsFor: 'visitation' stamp: 'sjh 5/29/2013 16:02'!visitSevenDay: aSevenDayOrder	| distance |	(InventoryManager getInstance orderItemsInStock: aSevenDayOrder)		ifTrue: [ distance := aSevenDayOrder location dist: (InventoryManager getInstance location).				 ^ (distance / 7) > speed ]		ifFalse: [ ^ false ].! !!PlaceabilityVisitor methodsFor: 'visitation' stamp: 'sjh 5/29/2013 16:11'!visitThreeDay: aThreeDayOrder	| distance |	"TODO: return an out of stock/too far indicator"	(InventoryManager getInstance orderItemsInStock: aThreeDayOrder)		ifTrue: [ distance := aThreeDayOrder location dist: (InventoryManager getInstance location).				 ^ (distance / 3) > speed ]		ifFalse: [ ^ false ].! !!PlaceabilityVisitor methodsFor: 'accessing' stamp: 'sjh 5/29/2013 16:01'!speed	^ 10! !Visitor subclass: #PrepareForPickVisitor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!PrepareForPickVisitor commentStamp: 'sjh 5/29/2013 15:31' prior: 0!Associate a priority with an Order!!PrepareForPickVisitor methodsFor: 'visitation' stamp: 'sjh 5/29/2013 15:30'!visitOneDay: aOneDayOrder	^ Array new; at: 1 put: 1; at: 2 put: aOneDayOrder! !!PrepareForPickVisitor methodsFor: 'visitation' stamp: 'sjh 5/29/2013 15:30'!visitSevenDay: aSevenDayOrder	^ Array new; at: 1 put: 7; at: 2 put: aSevenDayOrder! !!PrepareForPickVisitor methodsFor: 'visitation' stamp: 'sjh 5/29/2013 15:30'!visitThreeDay: aThreeDayOrder	^ Array new; at: 1 put: 3; at: 2 put: aThreeDayOrder! !