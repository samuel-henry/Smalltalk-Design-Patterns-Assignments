Object subclass: #Filter	instanceVariableNames: 'output'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!Filter commentStamp: 'sjh 5/7/2013 08:51' prior: 0!Abstract superclass!!Filter methodsFor: 'filtering' stamp: 'sjh 5/29/2013 14:56'!pullFrom: aPipe	"this should be implemented by concrete filters"	^ self subclassResponsibility! !!Filter methodsFor: 'filtering' stamp: 'sjh 5/29/2013 14:57'!push: someData to: aPipe	"push some data to the tail of a pipe" 	aPipe add: someData.! !!Filter methodsFor: 'observation' stamp: 'sjh 6/3/2013 12:59'!update: aPipe 	"sent when parent (object this instance is observing) changes state"	self pullFrom: aPipe.! !!Filter methodsFor: 'accessing' stamp: 'sjh 6/3/2013 13:00'!output	"outputs from this filter. can be pipes or queues"	^ output ifNil:[output := Dictionary new]! !Filter subclass: #CustomerNotifierFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!CustomerNotifierFilter commentStamp: 'sjh 5/29/2013 16:15' prior: 0!Notify customers of order status!!CustomerNotifierFilter methodsFor: 'filtering' stamp: 'sjh 6/3/2013 12:58'!pullFrom: aPipe	"write an order and its message to a new file--simulates emailing customer order status"	| input file |	aPipe isEmpty		ifFalse: [input := aPipe removeFirst.	 			file := FileDirectory default forceNewFileNamed: (Date today asString, String space, Time now print24). 				file nextPutAll: (input at: 'message'), String cr, (input at: 'order'); close. ].! !Object subclass: #InventoryManager	instanceVariableNames: 'location inventory'	classVariableNames: 'UniqueInstance'	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!InventoryManager commentStamp: 'sjh 6/3/2013 13:18' prior: 0!Maintain inventory status and replenishment!!InventoryManager methodsFor: 'initialize-release' stamp: 'sjh 5/30/2013 01:38'!initializeInventory	"create a dictionary of items and quantities"	inventory := Dictionary new. 	inventory at: 'SAM-56323' put: 5; at: 'SAM-76232' put: 10; at: 'SAM-23782' put: 7; at: 'SAM-48840' put: 93; at: 'SAM-22661' put: 13; at: 'SAM-45490' put: 22; at: 'SAM-33820' put: 64; at: 'SAM-88227' put: 2; at: 'SAM-33800' put: 17; at: 'SAM-99287' put: 22; at: 'SAM-42839' put: 1; at: 'SAM-57572' put: 33; at: 'SAM-48204' put: 5; at: 'SAM-50824' put: 3; at: 'SAM-24923' put: 0; at: 'SAM-37378' put: 4; at: 'SAM-09131' put: 2; at: 'SAM-47472' put: 25; at: 'SAM-34310' put: 54; at: 'SAM-59527' put: 10; at: 'SAM-46103' put: 5.! !!InventoryManager methodsFor: 'stockkeeping' stamp: 'sjh 6/1/2013 14:18'!checkOrderItemsInStock: anOrder	| leftover placeable aSku |	placeable := true.		"iterate over each item in the order. calculate the amount left after the desired order amount. if there is enough in stock (leftover >= 0), deplete the inventory by the desired amount, otherwise restock and specify that the order is not placeable due to insufficient stock of at least one item"	anOrder items associationsDo: [ :assoc | aSku := assoc key.						  leftover := (inventory at: aSku) - (assoc value).						  leftover < 0 							ifTrue: [ self replenish: aSku from: (leftover * -1).									 placeable := false. ]							ifFalse: [ inventory at: aSku put: leftover ] ].	^ placeable! !!InventoryManager methodsFor: 'stockkeeping' stamp: 'sjh 6/2/2013 17:56'!replenish: aSku from: shortcoming	"replenish our stock of this item by adding an additonal amount of inventory equal to twice the shortcoming"	inventory at: aSku put: ((inventory at: aSku) + (shortcoming *2))! !!InventoryManager methodsFor: 'accessing' stamp: 'sjh 5/30/2013 01:22'!inventory	^ inventory! !!InventoryManager methodsFor: 'accessing' stamp: 'sjh 6/4/2013 10:20'!inventory: anObject		inventory := anObject.! !!InventoryManager methodsFor: 'accessing' stamp: 'sjh 6/2/2013 17:46'!location	"location of warehouse"	^ Point x: 51 y: 50! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!InventoryManager class	instanceVariableNames: ''!!InventoryManager class methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:05'!getInstance	"return the Singleton instance of InventoryManager"	UniqueInstance isNil		ifTrue: [UniqueInstance := self basicNew initializeInventory ].	^UniqueInstance! !!InventoryManager class methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:05'!new	"override new to return an error if anyone tries to instantiate InventoryManager without calling getInstance"	self error: 'You may not instantiate InventoryManager using the new message. Use the getInstance message to get the singleton instance of InventoryManager'! !!InventoryManager class methodsFor: 'as yet unclassified' stamp: 'sjh 5/29/2013 15:05'!reset	UniqueInstance := nil.! !Filter subclass: #LoggerFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!LoggerFilter commentStamp: 'sjh 5/29/2013 16:15' prior: 0!Write orders to file!!LoggerFilter methodsFor: 'filtering' stamp: 'sjh 6/3/2013 15:14'!pullFrom: aPipe	"save a placed order to tab-delimited file (create it if it doesn't exist yet)--simulating Order database table"	| anOrder file |	aPipe isEmpty		ifFalse: [anOrder := aPipe removeFirst.				file := (FileDirectory default fileExists: (LoggerFilter logFileName)) 					ifTrue: [ FileDirectory default oldFileNamed: (LoggerFilter logFileName) ]					ifFalse: [ FileDirectory default forceNewFileNamed: (LoggerFilter logFileName) ].				file setToEnd nextPutAll: (anOrder printString, Date today asString, String space, Time now print24); cr; close ].							! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LoggerFilter class	instanceVariableNames: ''!!LoggerFilter class methodsFor: 'as yet unclassified' stamp: 'sjh 6/3/2013 15:14'!logFileName	^ 'SAM-Orders'! !Object subclass: #Order	instanceVariableNames: 'items location contactAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!Order commentStamp: 'sjh 6/3/2013 13:17' prior: 0!Abstract base class representing an order!!Order methodsFor: 'visitation' stamp: 'sjh 6/1/2013 13:16'!accept: aVisitor	^ self subclassResponsibility! !!Order methodsFor: 'accessing' stamp: 'sjh 5/29/2013 16:25'!contactAddress	^ contactAddress! !!Order methodsFor: 'accessing' stamp: 'sjh 5/29/2013 16:25'!contactAddress: anObject	contactAddress := anObject! !!Order methodsFor: 'accessing' stamp: 'sjh 5/29/2013 16:25'!items	^ items! !!Order methodsFor: 'accessing' stamp: 'sjh 5/29/2013 16:25'!items: anObject	items := anObject! !!Order methodsFor: 'accessing' stamp: 'sjh 6/1/2013 13:16'!location	^ location! !!Order methodsFor: 'accessing' stamp: 'sjh 5/29/2013 15:57'!location: anObject	location := anObject! !!Order methodsFor: 'accessing' stamp: 'sjh 6/3/2013 13:04'!printString	"return a pretty-printed represntation of this order"	| printableOrder |		printableOrder := contactAddress, String tab, location.	items associationsDo: [ :assoc | printableOrder := printableOrder, String tab, assoc key, String tab, assoc value asString ].		^ printableOrder! !!Order methodsFor: 'initialize-release' stamp: 'sjh 5/31/2013 17:32'!contactAddress: anAddress items: someItems location: aLocation	contactAddress := anAddress.	items := someItems.	location := aLocation.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Order class	instanceVariableNames: ''!!Order class methodsFor: 'as yet unclassified' stamp: 'sjh 5/31/2013 17:32'!contactAddress: anAddress items: someItems location: aLocation	^ self basicNew contactAddress: anAddress items: someItems location: aLocation! !!Order class methodsFor: 'as yet unclassified' stamp: 'sjh 6/1/2013 13:57'!getOrder: aRawOrder	"get a concrete order representing the passed in parameters. this is a modified implementation of http://stackoverflow.com/questions/3121102/smalltalk-equivalent-of-a-factory-method"	| matchingClass shippingMethod |		shippingMethod := aRawOrder at: 'shippingMethod'.	matchingClass := self subclasses detect: [ :first | first matching: shippingMethod ].	matchingClass isNil		ifTrue: [ ^self error: 'Unsupported shipping method' ]		ifFalse: [ ^matchingClass contactAddress: (aRawOrder at: 'contactAddress') items: (aRawOrder at: 'items') location: (aRawOrder at: 'location') ].! !!Order class methodsFor: 'as yet unclassified' stamp: 'sjh 6/1/2013 14:00'!matching: anObject	^self subclassResponsibility! !Order subclass: #OneDayOrder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!OneDayOrder commentStamp: 'sjh 6/3/2013 13:18' prior: 0!An order of one day shipping preference!!OneDayOrder methodsFor: 'visitation' stamp: 'sjh 5/29/2013 15:15'!accept: aVisitor	^ aVisitor visitOneDay: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneDayOrder class	instanceVariableNames: ''!!OneDayOrder class methodsFor: 'as yet unclassified' stamp: 'sjh 6/1/2013 14:00'!matching: anObject	^ anObject = 1! !Filter subclass: #OrderAccepterFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!OrderAccepterFilter commentStamp: 'sjh 5/29/2013 16:10' prior: 0!Take in a Dictionary representation of an order, pass it to the OrderFactory to get a concrete Order, then pipe this Order towards the PlaceabilityFilter!!OrderAccepterFilter methodsFor: 'filtering' stamp: 'sjh 6/3/2013 13:05'!pullFrom: aPipe	"take in a raw data representation of an order (from any source--EDI, web, data entry, fax, phone, etc), get an Order of the appropriate concrete type, and pipe it toward a placability filter"		aPipe isEmpty		ifFalse: [ self push: (Order getOrder: (aPipe removeFirst)) to: (self output at: 'placability') ].! !Filter subclass: #OrderCreatorFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!OrderCreatorFilter commentStamp: 'sjh 6/3/2013 13:17' prior: 0!Create an order by putting it in a queue for picking, logging the transaction in the system, and notifying the customer!!OrderCreatorFilter methodsFor: 'filtering' stamp: 'sjh 6/4/2013 10:19'!pullFrom: aPipe	| anOrder |	aPipe isEmpty		ifFalse: [anOrder := aPipe removeFirst.				"visit the order to attach a priority, then add it it to the PickQueue"				(output at: 'pickQueue') addMsg: (PickMessage new payload: (anOrder accept: PrepareForPickVisitor new)).					"put the order in the logger filter to store the transaction"				self push: anOrder to: (output at: 'logger'). 								"put the order in the notifier filter to inform the customer"				 self push: ((Dictionary new) at: 'message' put: (OrderCreatorFilter placedOrderMessage); at: 'order' put: anOrder; yourself) to: (output at: 'notifier')].		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OrderCreatorFilter class	instanceVariableNames: ''!!OrderCreatorFilter class methodsFor: 'as yet unclassified' stamp: 'sjh 6/2/2013 13:18'!placedOrderMessage	^'Your order has been placed'! !Filter subclass: #OrderPlacabilityFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!OrderPlacabilityFilter commentStamp: 'sjh 5/29/2013 15:38' prior: 0!Determine order placability in terms of the concrete order type, thecustomer's distance from the warehouse/days in transit, and the inventory status for each line item.!!OrderPlacabilityFilter methodsFor: 'filtering' stamp: 'sjh 6/3/2013 13:08'!pullFrom: aPipe	"visit an order to determine if it can be placed based on stock/distance, then pipe it to the appropriate output pipe (creator if placable, notifier if unplacable"	| anOrder |	aPipe isEmpty		ifFalse: [anOrder := aPipe removeFirst.				(anOrder accept: PlacabilityVisitor new)					ifTrue: [ self push: anOrder to: (output at: 'creator')  ]					ifFalse: [ self push: ((Dictionary new) at: 'message' put: (OrderPlacabilityFilter unplacableMessage); at: 'order' put: anOrder; yourself) to: (output at: 'notifier') ]].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OrderPlacabilityFilter class	instanceVariableNames: ''!!OrderPlacabilityFilter class methodsFor: 'as yet unclassified' stamp: 'sjh 6/1/2013 14:40'!unplacableMessage	^ 'Your order cannot be placed at this time'! !Object subclass: #PickMessage	instanceVariableNames: 'payload'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!PickMessage commentStamp: 'sjh 6/3/2013 13:09' prior: 0!Hold information about a unit of work to be put in a PickQueue!!PickMessage methodsFor: 'accessing' stamp: 'sjh 5/29/2013 14:59'!payload	^ payload! !!PickMessage methodsFor: 'accessing' stamp: 'sjh 5/29/2013 14:59'!payload: anObject	payload := anObject! !SortedCollection subclass: #PickQueue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!PickQueue commentStamp: 'sjh 6/3/2013 15:05' prior: 0!Priority Queue to hold orders that need to have their items picked from shelves!!PickQueue methodsFor: 'accessing' stamp: 'sjh 6/3/2013 15:05'!addMsg: aMessage	"add a message to the queue based on priority/time"	super add: aMessage.! !!PickQueue methodsFor: 'accessing' stamp: 'sjh 5/29/2013 14:58'!peek	"retrieve but do not remove the head of the queue"	^ super last! !!PickQueue methodsFor: 'accessing' stamp: 'sjh 5/29/2013 14:58'!popMsg	"remove the head of the queue"	^ super removeLast! !!PickQueue methodsFor: 'initialize-release' stamp: 'sjh 6/4/2013 10:22'!initialize	"set the sorting block to first order the queue's elements by priority then time added"	sortBlock := [:predecessor :successor | 	     			  ((predecessor payload) at: 'priority') = ((successor payload) at: 'priority')					ifTrue: [ ((predecessor payload) at: 'timeAdded') > ((successor payload) at: 'timeAdded')]					ifFalse: [ ((predecessor payload) at: 'priority') > ((successor payload) at: 'priority')] ].! !OrderedCollection subclass: #Pipe	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!Pipe commentStamp: 'sjh 5/7/2013 09:11' prior: 0!OrderedCollection already implements everything we need so far for a pipe!!Pipe methodsFor: 'accessing' stamp: 'sjh 6/1/2013 14:44'!add: anObject	"add this object to our pipe"	super addLast: anObject.		"notify dependents"	self changed: self.! !Order subclass: #SevenDayOrder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!SevenDayOrder commentStamp: 'sjh 6/3/2013 13:18' prior: 0!An order of seven day shipping preference!!SevenDayOrder methodsFor: 'visitation' stamp: 'sjh 5/29/2013 15:15'!accept: aVisitor	^ aVisitor visitSevenDay: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SevenDayOrder class	instanceVariableNames: ''!!SevenDayOrder class methodsFor: 'as yet unclassified' stamp: 'sjh 6/1/2013 14:01'!matching: anObject	^anObject = 7! !Order subclass: #ThreeDayOrder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!ThreeDayOrder commentStamp: 'sjh 6/3/2013 13:18' prior: 0!An order of three day shipping preference!!ThreeDayOrder methodsFor: 'visitation' stamp: 'sjh 5/29/2013 15:15'!accept: aVisitor	^ aVisitor visitThreeDay: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ThreeDayOrder class	instanceVariableNames: ''!!ThreeDayOrder class methodsFor: 'as yet unclassified' stamp: 'sjh 6/1/2013 14:04'!matching: anObject	^anObject = 3! !Object subclass: #Visitor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!Visitor commentStamp: 'sjh 6/3/2013 13:19' prior: 0!Abstract base class for visitation!!Visitor methodsFor: 'visitation' stamp: 'sjh 5/29/2013 15:12'!visitOneDay: aOneDayOrder	^ self subclassResponsibility! !!Visitor methodsFor: 'visitation' stamp: 'sjh 5/29/2013 15:13'!visitSevenDay: aSevenDayOrder	^ self subclassResponsibility! !!Visitor methodsFor: 'visitation' stamp: 'sjh 5/29/2013 15:13'!visitThreeDay: aThreeDayOrder	^ self subclassResponsibility! !Visitor subclass: #PlacabilityVisitor	instanceVariableNames: 'speed'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!PlacabilityVisitor commentStamp: 'sjh 6/3/2013 13:16' prior: 0!Visit an order to determine if it can be placed in terms of stock and distance to customer relative to shipping preference!!PlacabilityVisitor methodsFor: 'visitation' stamp: 'sjh 6/3/2013 13:10'!speed	"distance our delivery trucks can travel in one day"	^ 50! !!PlacabilityVisitor methodsFor: 'visitation' stamp: 'sjh 6/3/2013 13:13'!visitOneDay: aOneDayOrder	| distance |		(InventoryManager getInstance checkOrderItemsInStock: aOneDayOrder)		ifTrue: [ distance := aOneDayOrder location dist: (InventoryManager getInstance location).				 ^ distance <= self speed ]		ifFalse: [ ^ false ].! !!PlacabilityVisitor methodsFor: 'visitation' stamp: 'sjh 6/3/2013 13:13'!visitSevenDay: aSevenDayOrder	| distance |		(InventoryManager getInstance checkOrderItemsInStock: aSevenDayOrder)		ifTrue: [ distance := aSevenDayOrder location dist: (InventoryManager getInstance location).				 ^ (distance / 7) <= self speed ]		ifFalse: [ ^ false ].! !!PlacabilityVisitor methodsFor: 'visitation' stamp: 'sjh 6/2/2013 15:01'!visitThreeDay: aThreeDayOrder	| distance |		(InventoryManager getInstance checkOrderItemsInStock: aThreeDayOrder)		ifTrue: [ distance := aThreeDayOrder location dist: (InventoryManager getInstance location).				 ^ (distance / 3) <= self speed ]		ifFalse: [ ^ false ].! !Visitor subclass: #PrepareForPickVisitor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-FinalProject'!!PrepareForPickVisitor commentStamp: 'sjh 5/29/2013 15:31' prior: 0!Associate a priority with an Order!!PrepareForPickVisitor methodsFor: 'visitation' stamp: 'sjh 6/3/2013 14:57'!visitOneDay: aOneDayOrder	^ (Dictionary new) at: 'priority' put: 1; at: 'order' put: aOneDayOrder; at: 'timeAdded' put: DateAndTime now asUnixTime; yourself! !!PrepareForPickVisitor methodsFor: 'visitation' stamp: 'sjh 6/3/2013 14:57'!visitSevenDay: aSevenDayOrder	^(Dictionary new) at: 'priority' put: 7; at: 'order' put: aSevenDayOrder; at: 'timeAdded' put: DateAndTime now asUnixTime; yourself! !!PrepareForPickVisitor methodsFor: 'visitation' stamp: 'sjh 6/3/2013 14:57'!visitThreeDay: aThreeDayOrder	^ (Dictionary new) at: 'priority' put: 3; at: 'order' put: aThreeDayOrder; at: 'timeAdded' put: DateAndTime now asUnixTime;  yourself! !