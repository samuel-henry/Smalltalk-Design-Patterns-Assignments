Object subclass: #Component	instanceVariableNames: 'issuer'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW2'!!Component methodsFor: 'accessing' stamp: 'sjh 5/2/2013 14:01'!componentValue	^ self subclassResponsibility! !!Component methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:41'!issuer	^ issuer! !!Component methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:41'!issuer: anObject	issuer := anObject! !!Component methodsFor: 'as yet unclassified' stamp: 'sjh 5/3/2013 04:49'!addComponent: anObject	^self subclassResponsibility! !!Component methodsFor: 'as yet unclassified' stamp: 'sjh 5/3/2013 04:51'!getChild: anIndex	^self subclassResponsibility! !!Component methodsFor: 'as yet unclassified' stamp: 'sjh 5/3/2013 05:08'!iterator	^self subclassResponsibility! !!Component methodsFor: 'as yet unclassified' stamp: 'sjh 5/3/2013 04:49'!removeComponent: anObject	^self subclassResponsibility! !Component subclass: #Composite	instanceVariableNames: 'components iterator'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW2'!!Composite methodsFor: 'initialize-release' stamp: 'sjh 5/3/2013 05:09'!initialize	self components: OrderedCollection new.! !!Composite methodsFor: 'accessing' stamp: 'sjh 4/29/2013 21:06'!addComponent: anObject	components add: anObject! !!Composite methodsFor: 'accessing' stamp: 'sjh 5/2/2013 14:07'!componentValue	^ self components		inject: 0		into: [ :sum :component | sum + component componentValue ]! !!Composite methodsFor: 'accessing' stamp: 'sjh 4/29/2013 21:43'!components	^ components! !!Composite methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:41'!components: anObject	components := anObject! !!Composite methodsFor: 'accessing' stamp: 'sjh 5/6/2013 13:06'!iterator	^iterator isNil		ifTrue: [ iterator := PortfolioIterator on: components ]		ifFalse: [ iterator ]! !!Composite methodsFor: 'accessing' stamp: 'sjh 4/30/2013 11:32'!removeComponent: anObject	components remove: anObject! !!Composite methodsFor: 'as yet unclassified' stamp: 'sjh 5/3/2013 05:04'!getChild: anIndex	^components at: anIndex! !!Composite methodsFor: 'as yet unclassified' stamp: 'sjh 5/6/2013 16:09'!print 	| iterator component |	iterator := self iterator.	Transcript cr; show: issuer.	[iterator isDone]		whileFalse: [ iterator next.					 component := iterator currentItem.					 component print. ].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Composite class	instanceVariableNames: ''!!Composite class methodsFor: 'as yet unclassified' stamp: 'sjh 5/3/2013 05:03'!new	^self basicNew initialize.! !Composite subclass: #AccountComposite	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW2'!!AccountComposite methodsFor: 'accessing' stamp: 'sjh 4/29/2013 22:34'!addComponent: anObject(anObject isKindOf: Leaf) 	ifTrue: [ super addComponent: anObject ] 	ifFalse: [ self error: 'You may only add Leaf objects to AccountComposites' ]! !!AccountComposite methodsFor: 'as yet unclassified' stamp: 'sjh 5/6/2013 15:09'!iterator	| myIterator |	myIterator := PortfolioIterator new.	myIterator position: 0.	myIterator contents: self.	^myIterator! !Object subclass: #Iterator	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW2'!!Iterator commentStamp: 'sjh 5/6/2013 13:43' prior: 0!abstract iterator class. subclasses must implement isDone and next!!Iterator methodsFor: 'as yet unclassified' stamp: 'sjh 5/6/2013 13:42'!first	"initialize the current element to the first element"	^self subclassRepsonsibility! !!Iterator methodsFor: 'as yet unclassified' stamp: 'sjh 5/6/2013 15:04'!isDone	"test whether we've advanced beyond the last element"	^self subclassResponsibility! !!Iterator methodsFor: 'as yet unclassified' stamp: 'sjh 5/6/2013 13:43'!next	"advance the current element to the next element"	^self subclassResponsibility! !!Iterator methodsFor: 'accessing' stamp: 'sjh 5/6/2013 13:26'!contents	"return the contents (a collection) of the iterator"	^ contents! !!Iterator methodsFor: 'accessing' stamp: 'sjh 5/6/2013 13:26'!contents: anObject	"set the contents (a collection) of the iterator"	contents := anObject! !!Iterator methodsFor: 'accessing' stamp: 'sjh 5/6/2013 15:04'!currentItem	"return the current element in the list"	^self subclassResponsibility! !Component subclass: #Leaf	instanceVariableNames: 'componentValue'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW2'!!Leaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 04:54'!componentValue	^ componentValue! !!Leaf methodsFor: 'accessing' stamp: 'sjh 5/2/2013 14:03'!componentValue: anObject	componentValue := anObject! !!Leaf methodsFor: 'as yet unclassified' stamp: 'sjh 5/3/2013 04:56'!addComponent: anObject	^self error: 'You may not add a component to a Leaf'! !!Leaf methodsFor: 'as yet unclassified' stamp: 'sjh 5/3/2013 04:59'!getChild: anIndex	^self error: 'A leaf cannot have a child'! !!Leaf methodsFor: 'as yet unclassified' stamp: 'sjh 5/3/2013 05:11'!iterator	^ Nullterator new! !!Leaf methodsFor: 'as yet unclassified' stamp: 'sjh 5/6/2013 15:45'!print 	Transcript cr; show: issuer.	! !!Leaf methodsFor: 'as yet unclassified' stamp: 'sjh 5/3/2013 04:56'!removeComponent: anObject	^self error: 'You may not remove a component from a Leaf'! !Leaf subclass: #BondLeaf	instanceVariableNames: 'principal coupon issueDate'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW2'!!BondLeaf methodsFor: 'accessing' stamp: 'sjh 5/2/2013 14:04'!componentValue 	"calculate the value of a bond in terms of the principal and the interest that has accrued for a bond since its issuance"	| yearsSinceIssued today accruedValue |		"set tempBalance to the principal"	accruedValue := principal.		"get today"	today := Date today.		"get number of Jan 1sts since the bond was issued"	yearsSinceIssued :=  today year - issueDate year.		"for each of these, update tempBalance += interest rate * tempBalance" 	yearsSinceIssued timesRepeat: [ accruedValue := accruedValue + (coupon * accruedValue) ].			^ accruedValue ! !!BondLeaf methodsFor: 'accessing' stamp: 'sjh 4/29/2013 23:22'!coupon	^ coupon! !!BondLeaf methodsFor: 'accessing' stamp: 'sjh 4/29/2013 23:22'!coupon: anObject	coupon := anObject! !!BondLeaf methodsFor: 'accessing' stamp: 'sjh 4/29/2013 22:50'!issueDate	^ issueDate! !!BondLeaf methodsFor: 'accessing' stamp: 'sjh 4/29/2013 22:50'!issueDate: anObject	issueDate := anObject! !!BondLeaf methodsFor: 'accessing' stamp: 'sjh 4/29/2013 22:49'!principal	^ principal! !!BondLeaf methodsFor: 'accessing' stamp: 'sjh 4/29/2013 22:49'!principal: anObject	principal := anObject! !Leaf subclass: #MoneyMarketLeaf	instanceVariableNames: 'discountValue matureValue daysToMaturity issueDate'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW2'!!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/2/2013 14:03'!componentValue"calculate the value of a bond in terms of the principal and the interest that has accrued for a bond since its issuance"	| daysSinceIssued today |	"get today"	today := Date today.		"get number of days since the MoneyMarket security was issued"	daysSinceIssued :=  today subtractDate: issueDate.		"calculate value of MoneyMarket security:"	"if the security has matured, return the mature value"	"otherwise return the discount value + the amount of accrued value, calculated in terms of the value per day of accrual * number of days since issuance"	daysSinceIssued < daysToMaturity		ifTrue: [ ^ discountValue + (daysSinceIssued * ((matureValue - discountValue) / daysToMaturity)) ]		ifFalse: [ ^ matureValue ]! !!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:42'!daysToMaturity	^ daysToMaturity! !!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:42'!daysToMaturity: anObject	daysToMaturity := anObject! !!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:42'!discountValue	^ discountValue! !!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:42'!discountValue: anObject	discountValue := anObject! !!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:42'!issueDate	^ issueDate! !!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:42'!issueDate: anObject	issueDate := anObject! !!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:42'!matureValue	^ matureValue! !!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:42'!matureValue: anObject	matureValue := anObject! !ReadStream subclass: #Nullterator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW2'!!Nullterator methodsFor: 'as yet unclassified' stamp: 'sjh 5/3/2013 05:12'!hasNext	^false! !!Nullterator methodsFor: 'as yet unclassified' stamp: 'sjh 5/6/2013 13:59'!next	^ nil! !!Nullterator methodsFor: 'as yet unclassified' stamp: 'sjh 5/3/2013 05:13'!recursiveNext	^nil! !Composite subclass: #PortfolioComposite	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW2'!!PortfolioComposite methodsFor: 'accessing' stamp: 'sjh 5/6/2013 14:39'!iterator	| myIterator |	myIterator := PortfolioIterator new.	myIterator position: 0.	myIterator contents: self.	^myIterator! !Iterator subclass: #PortfolioIterator	instanceVariableNames: 'position'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW2'!!PortfolioIterator methodsFor: 'accessing' stamp: 'sjh 5/6/2013 14:42'!position	^ position! !!PortfolioIterator methodsFor: 'accessing' stamp: 'sjh 5/6/2013 14:42'!position: anObject	position := anObject! !!PortfolioIterator methodsFor: 'as yet unclassified' stamp: 'sjh 5/6/2013 15:05'!currentItem	^self contents components at: position! !!PortfolioIterator methodsFor: 'as yet unclassified' stamp: 'sjh 5/6/2013 14:43'!first	position := 1.! !!PortfolioIterator methodsFor: 'as yet unclassified' stamp: 'sjh 5/6/2013 14:43'!isDone	^ position > contents components size! !!PortfolioIterator methodsFor: 'as yet unclassified' stamp: 'sjh 5/6/2013 14:43'!next	position := position + 1.! !Object subclass: #PortfolioManager	instanceVariableNames: 'portfolio visitor'	classVariableNames: 'UniqueInstance'	poolDictionaries: ''	category: 'CSPP51050-HW2'!!PortfolioManager commentStamp: '<historical>' prior: 0!Singleton class for managing registration of students in Courses!!PortfolioManager methodsFor: 'initialize-release' stamp: 'sjh 5/6/2013 15:14'!initializePortfolio	"initialize portfolio instance variable to a new Portfolio"	self portfolio: PortfolioComposite new.	self visitor: PricingVisitor new.! !!PortfolioManager methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:43'!portfolio	^ portfolio! !!PortfolioManager methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:43'!portfolio: anObject	portfolio := anObject! !!PortfolioManager methodsFor: 'accessing' stamp: 'sjh 5/6/2013 15:14'!visitor	^ visitor! !!PortfolioManager methodsFor: 'accessing' stamp: 'sjh 5/6/2013 15:14'!visitor: anObject	visitor := anObject! !!PortfolioManager methodsFor: 'as yet unclassified' stamp: 'sjh 5/6/2013 15:19'!evaluate	| anIterator aComponent |	anIterator := portfolio iterator.	anIterator isDone		whileFalse:	[ 	anIterator next.						aComponent := anIterator currentItem.						visitor visit: aComponent.						anIterator := aComponent iterator. ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PortfolioManager class	instanceVariableNames: ''!!PortfolioManager class methodsFor: 'instance creation' stamp: 'sjh 4/29/2013 18:08'!getInstance	"return the Singleton instance of Registrar"	UniqueInstance isNil		ifTrue: [UniqueInstance := self basicNew initializePortfolio ].	^UniqueInstance! !!PortfolioManager class methodsFor: 'instance creation' stamp: 'sjh 4/29/2013 18:08'!new	"override new to return an error if anyone tries to instantiate PortfolioManager without calling getInstance"	self error: 'You may not instantiate PortfolioManager using the new message. Use the getInstance message to get the singleton instance of PortfolioManager'! !!PortfolioManager class methodsFor: 'instance creation' stamp: 'sjh 4/29/2013 18:03'!reset	UniqueInstance := nil.! !Object subclass: #PricingVisitor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW2'!!PricingVisitor methodsFor: 'visitation' stamp: 'sjh 4/29/2013 18:37'!visitAccount: anObject! !!PricingVisitor methodsFor: 'visitation' stamp: 'sjh 4/29/2013 18:37'!visitBond: anObject! !!PricingVisitor methodsFor: 'visitation' stamp: 'sjh 4/29/2013 18:37'!visitMoneyMarket: anObject! !!PricingVisitor methodsFor: 'visitation' stamp: 'sjh 4/29/2013 18:38'!visitPortfolio: anObject! !!PricingVisitor methodsFor: 'visitation' stamp: 'sjh 4/29/2013 18:37'!visitStock: anObject! !!PricingVisitor methodsFor: 'as yet unclassified' stamp: 'sjh 5/6/2013 15:19'!visit: aComponent! !Leaf subclass: #StockLeaf	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW2'!