Object subclass: #Component	instanceVariableNames: 'issuer'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable1'!!Component methodsFor: 'accessing' stamp: 'sjh 5/7/2013 12:55'!addComponent: anObject	"add a component to a component"	^self subclassResponsibility! !!Component methodsFor: 'accessing' stamp: 'sjh 5/7/2013 12:55'!componentValue	"get the value of a component"	^ self subclassResponsibility! !!Component methodsFor: 'accessing' stamp: 'sjh 5/7/2013 12:54'!issuer	"get the issuer of a component"	^ issuer! !!Component methodsFor: 'accessing' stamp: 'sjh 5/7/2013 12:54'!issuer: anObject	"set the issuer of a component"	issuer := anObject! !!Component methodsFor: 'accessing' stamp: 'sjh 5/7/2013 15:00'!iterate		"abstract message for iterating over a component's components--see concrete class implementations"	^self subclassResponsibility! !!Component methodsFor: 'accessing' stamp: 'sjh 5/7/2013 12:54'!iterator	"get a component's iterator"	^self subclassResponsibility! !!Component methodsFor: 'accessing' stamp: 'sjh 5/3/2013 04:49'!removeComponent: anObject	^self subclassResponsibility! !Component subclass: #Composite	instanceVariableNames: 'components'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable1'!!Composite methodsFor: 'initialize-release' stamp: 'sjh 5/3/2013 05:09'!initialize	self components: OrderedCollection new.! !!Composite methodsFor: 'accessing' stamp: 'sjh 4/29/2013 21:06'!addComponent: anObject	components add: anObject! !!Composite methodsFor: 'accessing' stamp: 'sjh 4/29/2013 21:43'!components	^ components! !!Composite methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:41'!components: anObject	components := anObject! !!Composite methodsFor: 'accessing' stamp: 'sjh 4/30/2013 11:32'!removeComponent: anObject	components remove: anObject! !!Composite methodsFor: 'visitation' stamp: 'sjh 5/7/2013 12:32'!accept: aVisitor	aVisitor visitComposite: self.! !!Composite methodsFor: 'visitation' stamp: 'sjh 5/7/2013 14:59'!iterate 	"iterate over a composite's components, iterating over them recursively"	| iterator component |	iterator := self iterator.	iterator first.	[iterator isDone]		whileFalse: [ component := iterator currentItem.					 component accept: PortfolioManager getInstance visitor.					 component iterate.					 iterator next. ].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Composite class	instanceVariableNames: ''!!Composite class methodsFor: 'as yet unclassified' stamp: 'sjh 5/3/2013 05:03'!new	^self basicNew initialize.! !Composite subclass: #AccountComposite	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable1'!!AccountComposite methodsFor: 'accessing' stamp: 'sjh 5/7/2013 12:44'!addComponent: anObject	"add a component to an account. make sure we can only add leaves to accounts"	(anObject isKindOf: Leaf) 		ifTrue: [ super addComponent: anObject ] "add a leaf"		ifFalse: [ self error: 'You may only add Leaf objects to AccountComposites' ] "error for adding a composite"! !!AccountComposite methodsFor: 'accessing' stamp: 'sjh 5/7/2013 12:50'!iterator	"get an AccountComposite's iterator -- TODO: rename PortfolioIterator to CompositeVisitor"	| myIterator |	myIterator := PortfolioIterator new. 	myIterator position: 0.	myIterator contents: self.	^myIterator! !Object subclass: #Iterator	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable1'!!Iterator commentStamp: 'sjh 5/6/2013 13:43' prior: 0!abstract iterator class. subclasses must implement isDone and next!!Iterator methodsFor: 'testing' stamp: 'sjh 5/6/2013 15:04'!isDone	"test whether we've advanced beyond the last element"	^self subclassResponsibility! !!Iterator methodsFor: 'accessing' stamp: 'sjh 5/6/2013 13:26'!contents	"return the contents (a collection) of the iterator"	^ contents! !!Iterator methodsFor: 'accessing' stamp: 'sjh 5/6/2013 13:26'!contents: anObject	"set the contents (a collection) of the iterator"	contents := anObject! !!Iterator methodsFor: 'accessing' stamp: 'sjh 5/6/2013 15:04'!currentItem	"return the current element in the list"	^self subclassResponsibility! !!Iterator methodsFor: 'accessing' stamp: 'sjh 5/6/2013 13:42'!first	"initialize the current element to the first element"	^self subclassRepsonsibility! !!Iterator methodsFor: 'accessing' stamp: 'sjh 5/6/2013 13:43'!next	"advance the current element to the next element"	^self subclassResponsibility! !Component subclass: #Leaf	instanceVariableNames: 'componentValue'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable1'!!Leaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 04:56'!addComponent: anObject	^self error: 'You may not add a component to a Leaf'! !!Leaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 04:54'!componentValue	^ componentValue! !!Leaf methodsFor: 'accessing' stamp: 'sjh 5/2/2013 14:03'!componentValue: anObject	componentValue := anObject! !!Leaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 05:11'!iterator	^ Nullterator new! !!Leaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 04:56'!removeComponent: anObject	^self error: 'You may not remove a component from a Leaf'! !!Leaf methodsFor: 'visitation' stamp: 'sjh 5/6/2013 16:51'!accept: aVisitor	^self subclassResponsibility! !!Leaf methodsFor: 'visitation' stamp: 'sjh 5/7/2013 14:59'!iterate 	"stub implementation of iterate for leaves"	! !Leaf subclass: #BondLeaf	instanceVariableNames: 'principal coupon issueDate'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable1'!!BondLeaf methodsFor: 'accessing' stamp: 'sjh 4/29/2013 23:22'!coupon	^ coupon! !!BondLeaf methodsFor: 'accessing' stamp: 'sjh 4/29/2013 23:22'!coupon: anObject	coupon := anObject! !!BondLeaf methodsFor: 'accessing' stamp: 'sjh 4/29/2013 22:50'!issueDate	^ issueDate! !!BondLeaf methodsFor: 'accessing' stamp: 'sjh 4/29/2013 22:50'!issueDate: anObject	issueDate := anObject! !!BondLeaf methodsFor: 'accessing' stamp: 'sjh 4/29/2013 22:49'!principal	^ principal! !!BondLeaf methodsFor: 'accessing' stamp: 'sjh 4/29/2013 22:49'!principal: anObject	principal := anObject! !!BondLeaf methodsFor: 'visitation' stamp: 'sjh 5/6/2013 16:52'!accept: aVisitor	^ aVisitor visitBond: self! !Leaf subclass: #MoneyMarketLeaf	instanceVariableNames: 'discountValue matureValue daysToMaturity issueDate'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable1'!!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:42'!daysToMaturity	^ daysToMaturity! !!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:42'!daysToMaturity: anObject	daysToMaturity := anObject! !!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:42'!discountValue	^ discountValue! !!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:42'!discountValue: anObject	discountValue := anObject! !!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:42'!issueDate	^ issueDate! !!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:42'!issueDate: anObject	issueDate := anObject! !!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:42'!matureValue	^ matureValue! !!MoneyMarketLeaf methodsFor: 'accessing' stamp: 'sjh 5/3/2013 07:42'!matureValue: anObject	matureValue := anObject! !!MoneyMarketLeaf methodsFor: 'visitation' stamp: 'sjh 5/6/2013 16:51'!accept: aVisitor	^ aVisitor visitMoneyMarket: self! !ReadStream subclass: #Nullterator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable1'!!Nullterator commentStamp: 'sjh 5/7/2013 13:00' prior: 0!Iterator for leaves. Never hasNext!!Nullterator methodsFor: 'testing' stamp: 'sjh 5/7/2013 13:02'!hasNext	"always false for a null iterator"	^false! !!Nullterator methodsFor: 'accessing' stamp: 'sjh 5/7/2013 13:02'!next	"always nil for a null iterator"	^ nil! !Composite subclass: #PortfolioComposite	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable1'!!PortfolioComposite methodsFor: 'accessing' stamp: 'sjh 5/6/2013 14:39'!iterator	| myIterator |	myIterator := PortfolioIterator new.	myIterator position: 0.	myIterator contents: self.	^myIterator! !Iterator subclass: #PortfolioIterator	instanceVariableNames: 'position'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable1'!!PortfolioIterator methodsFor: 'accessing' stamp: 'sjh 5/6/2013 15:05'!currentItem	^self contents components at: position! !!PortfolioIterator methodsFor: 'accessing' stamp: 'sjh 5/6/2013 14:43'!first	position := 1.! !!PortfolioIterator methodsFor: 'accessing' stamp: 'sjh 5/6/2013 14:43'!next	position := position + 1.! !!PortfolioIterator methodsFor: 'accessing' stamp: 'sjh 5/6/2013 14:42'!position	^ position! !!PortfolioIterator methodsFor: 'accessing' stamp: 'sjh 5/6/2013 14:42'!position: anObject	position := anObject! !!PortfolioIterator methodsFor: 'testing' stamp: 'sjh 5/6/2013 14:43'!isDone	^ position > contents components size! !Object subclass: #PortfolioManager	instanceVariableNames: 'portfolio visitor'	classVariableNames: 'UniqueInstance'	poolDictionaries: ''	category: 'CSPP51050-Deliverable1'!!PortfolioManager commentStamp: '<historical>' prior: 0!Singleton class for managing registration of students in Courses!!PortfolioManager methodsFor: 'initialize-release' stamp: 'sjh 5/7/2013 12:24'!initializePortfolio	"initialize portfolio instance variable to a new Portfolio"	self portfolio: PortfolioComposite new.	self visitor: PricingVisitor new.	self visitor sum: 0.! !!PortfolioManager methodsFor: 'accessing' stamp: 'sjh 5/7/2013 14:56'!evaluate	portfolio iterate.	Transcript cr; show: visitor sum.! !!PortfolioManager methodsFor: 'accessing' stamp: 'sjh 5/7/2013 13:03'!portfolio	^ portfolio! !!PortfolioManager methodsFor: 'accessing' stamp: 'sjh 5/7/2013 13:03'!portfolio: anObject	portfolio := anObject! !!PortfolioManager methodsFor: 'accessing' stamp: 'sjh 5/6/2013 15:14'!visitor	^ visitor! !!PortfolioManager methodsFor: 'accessing' stamp: 'sjh 5/6/2013 15:14'!visitor: anObject	visitor := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PortfolioManager class	instanceVariableNames: ''!!PortfolioManager class methodsFor: 'instance creation' stamp: 'sjh 4/29/2013 18:08'!getInstance	"return the Singleton instance of Registrar"	UniqueInstance isNil		ifTrue: [UniqueInstance := self basicNew initializePortfolio ].	^UniqueInstance! !!PortfolioManager class methodsFor: 'instance creation' stamp: 'sjh 4/29/2013 18:08'!new	"override new to return an error if anyone tries to instantiate PortfolioManager without calling getInstance"	self error: 'You may not instantiate PortfolioManager using the new message. Use the getInstance message to get the singleton instance of PortfolioManager'! !!PortfolioManager class methodsFor: 'instance creation' stamp: 'sjh 4/29/2013 18:03'!reset	UniqueInstance := nil.! !Object subclass: #PricingVisitor	instanceVariableNames: 'sum'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable1'!!PricingVisitor methodsFor: 'visitation' stamp: 'sjh 5/7/2013 12:36'!visitBond: aBond	"calculate the value of a bond in terms of the principal and the interest that has accrued for a bond since its issuance"	| yearsSinceIssued today accruedValue |		"set tempBalance to the principal"	accruedValue := aBond principal.		"get today"	today := Date today.		"get number of Jan 1sts since the bond was issued"	yearsSinceIssued :=  today year - aBond issueDate year.		"for each of these, update tempBalance += interest rate * tempBalance" 	yearsSinceIssued timesRepeat: [ accruedValue := accruedValue + (aBond coupon * accruedValue) ].			PortfolioManager getInstance visitor sum: PortfolioManager getInstance visitor sum + accruedValue.! !!PricingVisitor methodsFor: 'visitation' stamp: 'sjh 5/6/2013 17:19'!visitComposite: aComposite	Transcript cr; show: aComposite issuer.! !!PricingVisitor methodsFor: 'visitation' stamp: 'sjh 5/7/2013 12:36'!visitMoneyMarket: aMoneyMarketLeaf"calculate the value of a MoneyMarket security in terms of the principal and the interest that has accrued for a MoneyMarket security since its issuance"	| daysSinceIssued today |		"get today"	today := Date today.		"get number of days since the MoneyMarket security was issued"	daysSinceIssued :=  today subtractDate: aMoneyMarketLeaf issueDate.		"calculate value of MoneyMarket security:"	"if the security has matured, return the mature value"	"otherwise return the discount value + the amount of accrued value, calculated in terms of the value per day of accrual * number of days since issuance"	daysSinceIssued < aMoneyMarketLeaf daysToMaturity		ifTrue: [ 			PortfolioManager getInstance visitor sum: PortfolioManager getInstance visitor sum + (aMoneyMarketLeaf discountValue + (daysSinceIssued * ((aMoneyMarketLeaf matureValue - aMoneyMarketLeaf discountValue) / aMoneyMarketLeaf daysToMaturity)))			]		ifFalse: [ PortfolioManager getInstance visitor sum: PortfolioManager getInstance visitor sum +  aMoneyMarketLeaf matureValue ]! !!PricingVisitor methodsFor: 'visitation' stamp: 'sjh 5/7/2013 12:36'!visitStock: aStock	PortfolioManager getInstance visitor sum: PortfolioManager getInstance visitor sum + aStock componentValue.! !!PricingVisitor methodsFor: 'accessing' stamp: 'sjh 5/6/2013 22:50'!sum	^ sum! !!PricingVisitor methodsFor: 'accessing' stamp: 'sjh 5/6/2013 22:50'!sum: anObject	sum := anObject! !Leaf subclass: #StockLeaf	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable1'!!StockLeaf methodsFor: 'visitation' stamp: 'sjh 5/6/2013 16:52'!accept: aVisitor	^ aVisitor visitStock: self! !