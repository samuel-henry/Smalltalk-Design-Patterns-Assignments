'From Squeak4.4 of 31 December 2012 [latest update: #12327] on 15 April 2013 at 1:46:20 pm'!Object subclass: #ChangeSet	instanceVariableNames: 'name preamble postscript revertable isolationSet isolatedProject changeRecords structures superclasses'	classVariableNames: 'AllChangeSets PreviousSet'	poolDictionaries: ''	category: 'System-Changes'!!ChangeSet commentStamp: '<historical>' prior: 0!ChangeSets keep track of the changes made to a system, so they can be written on a file as source code (a "fileOut").  Every project has an associated changeSet.  For simple projects, a different changeSet may be designated to capture changes at any time.This implementation of ChangeSet is capable of remembering and manipulating methods for which the classes are not present in the system.  However at the present time, this capability is not used in normal rearranging and fileOuts, but only for invoking and revoking associated with isolation layers.For isolated projects (see Project class comment), the changeSet binding is semi-permanent.  Every project exists in an isolation layer defined by its closest enclosing parent (or itself) that is isolated.  If a project is not isolated, then changes reported to its designated changeSet must also be reported to the permanent changeSet for that layer, designated in the isolated project.  This ensures that that outer project will be able to revert all changes upon exit.Note that only certain changes may be reverted.  Classes may not be added, removed, renamed or reshaped except in the layer in which they are defined because these operations on non-local classes are not revertable.If a Squeak Project is established as being isolated, then its associated changeSet will be declared to be revertable.  In this case all changes stored can be reverted.  The changeSet associated with an isolated project is tied to that project, and cannot be edited in a changeSorter.------name - a String used to name the changeSet, and thus any associated project or fileOut.preamble and postscript:  two strings that serve as prefix (useful for documentation) and suffix (useful for doits) to the fileout of the changeSet.revertable - a BooleanIf this variable is true, then all of the changes recorded by this changeSet can be reverted.isolationSet - a ChangeSet or nilThe isolationSet is the designated changeSet for an isolation layer.  If this changeSet is an isolationSet, then this variable will be nil.  If not, then it points to the isolationSet for this layer, and all changes reported here will also be reported to the isolationSet.isolatedProject - a Project or nilIf this is an isolationSet, then this variable points to the project with which it is associated.changeRecords -  Dictionary {class name -> a ClassChangeRecord}.These classChangeRecords (qv) remember all of the system changes.structures -    Dictionary {#Rectangle -> #(<classVersionInteger> 'origin' 'corner')}.Of  the names of the instances variables before any changes for all classes in classChanges, and all of their superclasses.  In the same format used in SmartRefStream.  Inst var names are strings.  superclasses -    Dictionary {#Rectangle -> #Object}.Of all classes in classChanges, and all of their superclasses.Structures and superclasses save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp).NOTE:  It should be fairly simple, by adding a bit more information to the classChangeRecords, to reconstruct the information now stored in 'structures' and 'superclasses'.  This would be a welcome simplification.!!ChangeSet methodsFor: 'accessing' stamp: 'BJP 4/24/2001 00:23'!author	| author |	self assurePreambleExists.	author := self preambleString lineNumber: 3.	author := author copyFrom: 8 to: author size. "Strip the 'Author:' prefix. Ugly ugly."		^author withBlanksTrimmed.	! !!ChangeSet methodsFor: 'accessing' stamp: 'di 4/1/2000 12:00'!classRemoves	^ changeRecords keys select:		[:className | (changeRecords at: className) isClassRemoval]! !!ChangeSet methodsFor: 'accessing' stamp: 'ar 7/16/2005 18:59'!editPostscript	"edit the receiver's postscript, in a separate window.  "	self assurePostscriptExists.	UIManager default		edit: self postscript 		label: 'Postscript for ChangeSet named ', name		accept:[:aString| self postscript: aString].! !!ChangeSet methodsFor: 'accessing' stamp: 'sw 6/29/1999 14:44'!hasPostscript	^ postscript notNil! !!ChangeSet methodsFor: 'accessing' stamp: 'nice 12/27/2009 03:11'!methodChanges	| methodChangeDict |	methodChangeDict := Dictionary new.	changeRecords associationsDo:		[:assn | | changeTypes |		changeTypes := assn value methodChangeTypes.		changeTypes isEmpty ifFalse: [methodChangeDict at: assn key put: changeTypes]].	^ methodChangeDict! !!ChangeSet methodsFor: 'accessing' stamp: 'di 3/29/2000 16:22'!methodInfoFromRemoval: classAndSelector	^ (self changeRecorderFor: classAndSelector first)		infoFromRemoval: classAndSelector last! !!ChangeSet methodsFor: 'accessing'!name	"The name of this changeSet.	 2/7/96 sw: If name is nil, we've got garbage.  Help to identify."	^ name == nil		ifTrue:			['<no name -- garbage?>']		ifFalse:			[name]! !!ChangeSet methodsFor: 'accessing'!name: anObject	name := anObject! !!ChangeSet methodsFor: 'accessing' stamp: 'ar 7/16/2005 18:04'!postscriptHasDependents	^false! !!ChangeSet methodsFor: 'accessing'!printOn: aStream	"2/7/96 sw: provide the receiver's name in the printout"	super printOn: aStream.	aStream nextPutAll: ' named ', self name! !!ChangeSet methodsFor: 'accessing' stamp: 'MPW 1/1/1901 22:02'!printOnStream: aStream	"2/7/96 sw: provide the receiver's name in the printout"	super printOnStream: aStream.	aStream print: ' named ', self name! !!ChangeSet methodsFor: 'accessing' stamp: 'sw 6/29/1999 14:48'!removePostscript	postscript := nil! !!ChangeSet methodsFor: 'accessing' stamp: 'tk 6/8/1999 22:25'!structures	^structures! !!ChangeSet methodsFor: 'accessing' stamp: 'tk 6/8/1999 22:25'!superclasses	^superclasses! !!ChangeSet methodsFor: 'change logging' stamp: 'di 3/29/2000 13:10'!addClass: class 	"Include indication that a new class was created."	class wantsChangeSetLogging ifFalse: [^ self].	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet addClass: class].	self atClass: class add: #new.	self atClass: class add: #change.	self addCoherency: class name! !!ChangeSet methodsFor: 'change logging' stamp: 'NS 1/19/2004 18:30'!changeClass: class from: oldClass	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."	class wantsChangeSetLogging ifFalse: [^ self]. 	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet changeClass: class from: oldClass].	class isMeta 		ifFalse: [self atClass: class add: #change]	"normal"		ifTrue: [((self classChangeAt: class theNonMetaClass name) includes: #add) 			ifTrue: [self atClass: class add: #add] 	"When a class is defined, the metaclass				is not recorded, even though it was added.  A further change is				really just part of the original add."			ifFalse: [self atClass: class add: #change]].	self addCoherency: class name.	(self changeRecorderFor: class) notePriorDefinition: oldClass.	self noteClassStructure: oldClass! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/17/2006 22:26'!event: anEvent	"Hook for SystemChangeNotifier"	anEvent itemKind = SystemChangeNotifier classKind ifTrue: [		anEvent isRemoved 			ifTrue: [self noteRemovalOf: anEvent item].		anEvent isAdded 			ifTrue: [self addClass: anEvent item].		anEvent isModified 			ifTrue: [anEvent anyChanges ifTrue: [self changeClass: anEvent item from: anEvent oldItem]].		anEvent isCommented 			ifTrue: [self commentClass: anEvent item].		anEvent isRenamed 			ifTrue: [self renameClass: anEvent item from: anEvent oldName to: anEvent newName].		anEvent isReorganized			ifTrue: [self reorganizeClass: anEvent item].		anEvent isRecategorized			ifTrue: [self changeClass: anEvent item from: anEvent item].	].	anEvent itemKind = SystemChangeNotifier methodKind ifTrue: [		anEvent isAdded			ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: nil].		anEvent isModified			ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: anEvent oldItem].		anEvent isRemoved			ifTrue: [self removeSelector: anEvent itemSelector class: anEvent itemClass priorMethod: anEvent item lastMethodInfo: {anEvent item sourcePointer. anEvent itemProtocol}].		anEvent isRecategorized			ifTrue: [self reorganizeClass: anEvent itemClass].	].! !!ChangeSet methodsFor: 'change logging' stamp: 'di 3/29/2000 11:08'!noteNewMethod: newMethod forClass: class selector: selector priorMethod: methodOrNil	class wantsChangeSetLogging ifFalse: [^ self].	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet noteNewMethod: newMethod forClass: class selector: selector				priorMethod: methodOrNil].	(self changeRecorderFor: class)		noteNewMethod: newMethod selector: selector priorMethod: methodOrNil! !!ChangeSet methodsFor: 'change logging' stamp: 'di 3/29/2000 12:29'!removeSelector: selector class: class priorMethod: priorMethod lastMethodInfo: info	"Include indication that a method has been forgotten.	info is a pair of the source code pointer and message category	for the method that was removed."	class wantsChangeSetLogging ifFalse: [^ self].	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet removeSelector: selector class: class				priorMethod: priorMethod lastMethodInfo: info].	(self changeRecorderFor: class)		noteRemoveSelector: selector priorMethod: priorMethod lastMethodInfo: info! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/19/2006 17:52'!renameClass: class from: oldName to: newName 	"Include indication that a class has been renamed."	| recorder oldMetaClassName newMetaClassName |	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet renameClass: class as: newName].	(recorder := self changeRecorderFor: oldName)		noteChangeType: #rename;		noteNewName: newName asSymbol.			"store under new name (metaclass too)"	changeRecords at: newName put: recorder.	changeRecords removeKey: oldName.	self noteClassStructure: class.	newMetaClassName := newName, ' class'.	oldMetaClassName := oldName, ' class'.	recorder := changeRecords at: oldMetaClassName ifAbsent: [^ nil].	changeRecords at: newMetaClassName put: recorder.	changeRecords removeKey: oldMetaClassName.	recorder noteNewName: newMetaClassName! !!ChangeSet methodsFor: 'class changes' stamp: 'di 4/1/2000 12:00'!changedClassNames	"Answer a OrderedCollection of the names of changed or edited classes.	DOES include removed classes.  Sort alphabetically."	^ changeRecords keysSortedSafely ! !!ChangeSet methodsFor: 'class changes' stamp: 'di 3/23/2000 08:12'!changedClasses	"Answer an OrderedCollection of changed or edited classes.	Does not include removed classes.  Sort alphabetically by name."	"Much faster to sort names first, then convert back to classes.  Because metaclasses reconstruct their name at every comparison in the sorted collection.	8/91 sw chgd to filter out non-existent classes (triggered by problems with class-renames"	^ self changedClassNames		collect: [:className | Smalltalk classNamed: className]		thenSelect: [:aClass | aClass notNil]! !!ChangeSet methodsFor: 'class changes' stamp: 'di 4/1/2000 12:00'!classChangeAt: className	"Return what we know about class changes to this class."	^ (changeRecords at: className ifAbsent: [^ Set new])		allChangeTypes! !!ChangeSet methodsFor: 'class changes' stamp: 'NS 1/26/2004 09:46'!commentClass: class 	"Include indication that a class comment has been changed."	class wantsChangeSetLogging ifFalse: [^ self].	self atClass: class add: #comment! !!ChangeSet methodsFor: 'class changes' stamp: 'nk 6/26/2002 12:30'!containsClass: aClass	^ self changedClasses includes: aClass! !!ChangeSet methodsFor: 'class changes' stamp: 'dvf 9/27/2005 19:04'!fatDefForClass: class	| newDef oldDef oldStrm newStrm outStrm oldVars newVars addedVars |		class isBehavior ifFalse: [^class definition].		newDef := class definition.	oldDef := (self changeRecorderFor: class) priorDefinition.	oldDef ifNil: [^ newDef].	oldDef = newDef ifTrue: [^ newDef].	oldStrm := ReadStream on: oldDef.	newStrm := ReadStream on: newDef.	outStrm := WriteStream on: (String new: newDef size * 2).	"Merge inst vars from old and new defs..."	oldStrm upToAll: 'instanceVariableNames'; upTo: $'.	outStrm 		nextPutAll: (newStrm upToAll: 'instanceVariableNames'); 		nextPutAll: 'instanceVariableNames:'.	newStrm peek = $: ifTrue: [newStrm next].	"may or may not be there, but already written"	outStrm		nextPutAll: (newStrm upTo: $'); nextPut: $'.	oldVars := (oldStrm upTo: $') findTokens: Character separators.	newVars := (newStrm upTo: $') findTokens: Character separators.	addedVars := oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.	oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].	outStrm nextPut: $'.	class isMeta ifFalse:		["Merge class vars from old and new defs..."		oldStrm upToAll: 'classVariableNames:'; upTo: $'.		outStrm nextPutAll: (newStrm upToAll: 'classVariableNames:'); nextPutAll: 'classVariableNames:';			nextPutAll: (newStrm upTo: $'); nextPut: $'.		oldVars := (oldStrm upTo: $') findTokens: Character separators.		newVars := (newStrm upTo: $') findTokens: Character separators.		addedVars := oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.		oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].		outStrm nextPut: $'].	outStrm nextPutAll: newStrm upToEnd.	^ outStrm contents! !!ChangeSet methodsFor: 'class changes' stamp: 'tk 6/9/1999 19:54'!noteClassForgotten: className	"Remove from structures if class is not a superclass of some other one we are remembering"	structures ifNil: [^ self].	Smalltalk at: className ifPresent: [:cls |		cls subclasses do: [:sub | (structures includesKey: sub) ifTrue: [			^ self]]].  "No delete"	structures removeKey: className ifAbsent: [].! !!ChangeSet methodsFor: 'class changes' stamp: 'dvf 9/27/2005 19:05'!noteClassStructure: aClass	"Save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp)."	| clsName |	aClass isBehavior ifFalse: [^ self].		structures ifNil: [structures := Dictionary new.				superclasses := Dictionary new].	clsName := (aClass name asLowercase beginsWith: 'anobsolete') 		ifTrue: [(aClass name copyFrom: 11 to: aClass name size) asSymbol]		ifFalse: [aClass name].	(structures includesKey: clsName) ifFalse: [		structures at: clsName put: 			((Array with: aClass classVersion), (aClass allInstVarNames)).		superclasses at: clsName put: aClass superclass name].	"up the superclass chain"	aClass superclass ifNotNil: [self noteClassStructure: aClass superclass].! !!ChangeSet methodsFor: 'class changes' stamp: 'NS 1/19/2004 17:49'!noteRemovalOf: class	"The class is about to be removed from the system.	Adjust the receiver to reflect that fact."	class wantsChangeSetLogging ifFalse: [^ self].	(self changeRecorderFor: class)		noteChangeType: #remove fromClass: class.	changeRecords removeKey: class class name ifAbsent: [].! !!ChangeSet methodsFor: 'class changes'!reorganizeClass: class 	"Include indication that a class was reorganized."	self atClass: class add: #reorganize! !!ChangeSet methodsFor: 'class changes' stamp: 'di 5/16/2000 09:03'!trimHistory 	"Drop non-essential history:  methods added and then removed, as well as rename and reorganization of newly-added classes."	changeRecords do: [:chgRecord | chgRecord trimHistory]! !!ChangeSet methodsFor: 'converting' stamp: 'nice 12/27/2009 03:11'!convertApril2000: varDict using: smartRefStrm	| classChanges methodChanges methodRemoves classRemoves cls info |	"These variables are automatically stored into the new instance:		('name' 'preamble' 'postscript' 'structures' 'superclasses' ).	This method is for additional changes.	It initializes the isolation variables, and then duplicates the logic fo		assimilateAllChangesFoundIn:."	revertable := false.	isolationSet := nil.	isolatedProject := nil.	changeRecords := Dictionary new.	classChanges := varDict at: 'classChanges'.	classChanges keysDo:		[:className |	  	(cls := Smalltalk classNamed: className) ifNotNil:			[info := classChanges at: className ifAbsent: [Set new].			info do: [:each | self atClass: cls add: each]]].	methodChanges := varDict at: 'methodChanges'.	methodRemoves := varDict at: 'methodRemoves'.	methodChanges keysDo:		[:className |	  	(cls := Smalltalk classNamed: className) ifNotNil:			[info := methodChanges at: className ifAbsent: [Dictionary new].			info associationsDo:				[:assoc | | selector pair | selector := assoc key.				(assoc value == #remove or: [assoc value == #addedThenRemoved])					ifTrue:						[assoc value == #addedThenRemoved							ifTrue: [self atSelector: selector class: cls put: #add].						pair := methodRemoves at: {cls name. selector} ifAbsent: [nil] .						self removeSelector: selector class: cls priorMethod: nil lastMethodInfo: pair]					ifFalse: 						[self atSelector: selector class: cls put: assoc value]]]].	classRemoves := varDict at: 'classRemoves'.	classRemoves do:		[:className | self noteRemovalOf: className].! !!ChangeSet methodsFor: 'converting' stamp: 'nice 12/27/2009 03:11'!convertToCurrentVersion: varDict refStream: smartRefStrm	"major change - 4/4/2000"		varDict at: 'classChanges' ifPresent: [ :x | | newish |		newish := self convertApril2000: varDict using: smartRefStrm.		newish == self ifFalse: [^ newish].		].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nice 12/27/2009 03:11'!askAddedInstVars: classList	| pairList pairClasses index pls |	"Ask the author whether these newly added inst vars need to be non-nil"	pairList := OrderedCollection new.	pairClasses := OrderedCollection new.	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."	classList do: [:cls | | newStruct oldStruct |		newStruct := (cls allInstVarNames).		oldStruct := (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.		newStruct do: [:instVarName |			(oldStruct includes: instVarName) ifFalse: [				pairList add: cls name, ' ', instVarName.				pairClasses add: cls]]].	pairList isEmpty ifTrue: [^ #()].	[index := UIManager default 		chooseFrom: pairList, #('all of these need a non-nil value'						'all of these are OK with a nil value')		title:'These instance variables were added.When an old project comes in, newly added instance variables will have the value nil.Click on items to remove them from the list.Click on any for which nil is an OK value.'.	(index <= (pls := pairList size)) & (index > 0) ifTrue: [		pairList removeAt: index.		pairClasses removeAt: index].	index = (pls + 2) ifTrue: ["all are OK" ^ #()].	pairList isEmpty | (index = (pls + 1)) "all need conversion, exit"] whileFalse.	^ pairClasses asSet asArray	"non redundant"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nice 12/27/2009 03:11'!askRemovedInstVars: classList	| pairList pairClasses index pls |	"Ask the author whether these newly removed inst vars need to have their info saved"	pairList := OrderedCollection new.	pairClasses := OrderedCollection new.	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."	classList do: [:cls | | oldStruct newStruct |		newStruct := (cls allInstVarNames).		oldStruct := (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.		oldStruct do: [:instVarName |			(newStruct includes: instVarName) ifFalse: [				pairList add: cls name, ' ', instVarName.				pairClasses add: cls]]].	pairList isEmpty ifTrue: [^ #()].	[index := UIManager default 		chooseFrom: pairList, #('all of these need a conversion method'						'all of these have old values that can be erased')			title:'These instance variables were removed.When an old project comes in, instance variables that have been removed will lose their contents.Click on items to remove them from the list.Click on any whose value is unimportant and need not be saved.'.	(index <= (pls := pairList size)) & (index > 0) ifTrue: [		pairList removeAt: index.		pairClasses removeAt: index].	index = (pls + 2) ifTrue: ["all are OK" ^ #()].	pairList isEmpty | (index = (pls + 1))  "all need conversion, exit"] whileFalse.	^ pairClasses asSet asArray	"non redundant"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nice 12/27/2009 03:11'!askRenames: renamed addTo: msgSet using: smart	| list |	"Go through the renamed classes.  Ask the user if it could be in a project.  Add a method in SmartRefStream, and a conversion method in the new class."	list := OrderedCollection new.	renamed do: [:cls | | rec ans oldStruct newStruct |		rec := changeRecords at: cls name.		rec priorName ifNotNil: [			ans := UIManager default chooseFrom: 					#('Yes, write code to convert those instances'					'No, no instances are in projects')				title: 'You renamed class ', rec priorName, 				' to be ', rec thisName,				'.\Could an instance of ', rec priorName, 				' be in a project on someone''s disk?'.			ans = 1 ifTrue: [					oldStruct := structures at: rec priorName ifAbsent: [nil].					newStruct := (Array with: cls classVersion), (cls allInstVarNames).					oldStruct ifNotNil: [						smart writeConversionMethodIn: cls fromInstVars: oldStruct 								to: newStruct renamedFrom: rec priorName.						smart writeClassRename: cls name was: rec priorName.						list add: cls name, ' convertToCurrentVersion:refStream:']]				ifFalse: [structures removeKey: rec priorName ifAbsent: []]]].	list isEmpty ifTrue: [^ msgSet].	msgSet messageList ifNil: [msgSet initializeMessageList: list]		ifNotNil: [list do: [:item | msgSet addItem: item]].	^ msgSet! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/16/2005 18:05'!assurePostscriptExists	"Make sure there is a StringHolder holding the postscript.  "	"NOTE: FileIn recognizes the postscript by the line with Postscript: on it"	postscript == nil ifTrue: [postscript := '"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/16/2005 18:02'!assurePreambleExists	"Make sure there is a StringHolder holding the preamble; if it's found to have reverted to empty contents, put up the template"	(preamble isEmptyOrNil)		ifTrue: [preamble := self preambleTemplate]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ls 10/21/2001 21:09'!buildMessageForMailOutWithUser: userName	| message compressBuffer compressStream data compressedStream compressTarget |	"prepare the message"	message := MailMessage empty.	message setField: 'from' toString: userName.	message setField: 'to' toString: 'squeak-dev@lists.squeakfoundation.org'.	message setField: 'subject' toString: (self chooseSubjectPrefixForEmail, name). 	message body: (MIMEDocument contentType: 'text/plain' content: (String streamContents: [ :str |		str nextPutAll: 'from preamble:'; cr; cr.		self fileOutPreambleOn: str ])).	"Prepare the gzipped data"	data := WriteStream on: String new.	data header; timeStamp.	self fileOutPreambleOn: data.	self fileOutOn: data.	self fileOutPostscriptOn: data.	data trailer.	data := ReadStream on: data contents.	compressBuffer := ByteArray new: 1000.	compressStream := GZipWriteStream on: (compressTarget := WriteStream on: (ByteArray new: 1000)).	[data atEnd]		whileFalse: [compressStream nextPutAll: (data nextInto: compressBuffer)].	compressStream close.	compressedStream := ReadStream on: compressTarget contents asString.	message addAttachmentFrom: compressedStream withName: (name, '.cs.gz').	^ message! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'cmm 3/9/2010 10:16'!checkForAlienAuthorship	"Check to see if there are any methods in the receiver that have author initials other than that of the current author, and open a browser on all found"	| aList initials |	(initials := Utilities authorInitials) isEmptyOrNil ifTrue: [ ^self inform: 'No author initials set in this image' ].	(aList := self methodsWithInitialsOtherThan: initials) size > 0		ifTrue:			[ self systemNavigation				browseMessageList: aList				name: 'methods in "' , self name , '" whose authoring stamps do not start with "' , initials , '"' ]		ifFalse: [ ^self inform: 'All methods in "' , self name , '"have authoring stamps which start with "' , initials , '"' ]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'cmm 3/9/2010 10:17'!checkForAnyAlienAuthorship	"Check to see if there are any versions of any methods in the receiver that have author initials other than that of the current author, and open a browser on all found"	| aList initials |	(initials := Utilities authorInitials) isEmptyOrNil ifTrue: [ ^self inform: 'No author initials set in this image' ].	(aList := self methodsWithAnyInitialsOtherThan: initials) size > 0		ifTrue:			[ self systemNavigation				browseMessageList: aList				name: 'methods in "' , self name , '" with any authoring stamps not starting with "' , initials , '"' ]		ifFalse: [ ^self inform: 'All versions of all methods in "' , self name , '"have authoring stamps which start with "' , initials , '"' ]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'cmm 2/17/2010 21:59'!checkForConversionMethods	"See if any conversion methods are needed"	| tell choice smart restore renamed listAdd listDrop msgSet list |	Preferences conversionMethodsAtFileOut ifFalse: [^ self].	"Check preference"	structures ifNil: [^ self].	list := OrderedCollection new.	renamed := OrderedCollection new.	self changedClasses do: [:class | | newStruct sel oldStruct need rec |		need := (self atClass: class includes: #new) not.		need ifTrue: ["Renamed classes."			(self atClass: class includes: #rename) ifTrue: [				rec := changeRecords at: class name.				rec priorName ifNotNil: [					(structures includesKey: rec priorName) ifTrue: [						renamed add: class.  need := false]]]].		need ifTrue: [need := (self atClass: class includes: #change)].		need ifTrue: [oldStruct := structures at: class name 									ifAbsent: [need := false.  #()]].		need ifTrue: [			newStruct := (Array with: class classVersion), (class allInstVarNames).			need := (oldStruct ~= newStruct)].		need ifTrue: [sel := #convertToCurrentVersion:refStream:.			(#(add change) includes: (self atSelector: sel class: class)) ifFalse: [				list add: class]].		].	list isEmpty & renamed isEmpty ifTrue: [^ self].	"Ask user if want to do this"	tell := 'If there might be instances of ', (list asArray, renamed asArray) printString,		'\in a project (.pr file) on someone''s disk, \please ask to write a conversion method.\'			withCRs,		'After you edit the conversion method, you''ll need to fileOut again.\' withCRs,		'The preference conversionMethodsAtFileOut in category "fileout" controls this feature.'.	choice := UIManager default chooseFrom:'Write a conversion method by editing a prototypeThese classes are not used in any object file.  fileOut my changes now.I''m too busy.  fileOut my changes now.Don''t ever ask again.  fileOut my changes now.' withCRs title: tell. 	choice = 4 ifTrue: [Preferences disable: #conversionMethodsAtFileOut].	choice = 2 ifTrue: ["Don't consider this class again in the changeSet"			list do: [:cls | structures removeKey: cls name ifAbsent: []].			renamed do: [:cls | | nn | 				nn := (changeRecords at: cls name) priorName.				structures removeKey: nn ifAbsent: []]].	choice ~= 1 ifTrue: [^ self].	"exit if choice 2,3,4"	listAdd := self askAddedInstVars: list.	"Go through each inst var that was added"	listDrop := self askRemovedInstVars: list.	"Go through each inst var that was removed"	list := (listAdd, listDrop) asSet asArray.	smart := SmartRefStream on: (RWBinaryOrTextStream on: '12345').	smart structures: structures.	smart superclasses: superclasses.	(restore := self class current) == self ifFalse: [		self class  newChanges: self].	"if not current one"	msgSet := smart conversionMethodsFor: list.		"each new method is added to self (a changeSet).  Then filed out with the rest."	self askRenames: renamed addTo: msgSet using: smart.	"renamed classes, add 2 methods"	restore == self ifFalse: [self class newChanges: restore].	msgSet isEmpty ifTrue: [^ self].	self inform: 'Remember to fileOut again after modifying these methods.'.	ToolSet 		browseMessageSet: msgSet 		name: 'Conversion methods for ', self name 		autoSelect: nil! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nice 12/27/2009 03:11'!checkForSlips	"Return a collection of method refs with possible debugging code in them."	| slips |	slips := OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | | method | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[method := aClass compiledMethodAt: mAssoc key ifAbsent: [nil].					method ifNotNil:						[method hasReportableSlip							ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 4/16/2003 09:16'!checkForUnclassifiedMethods	"Open a message list browser on all methods in the current change set that have not been categorized,"	| aList |	(aList := self methodsWithoutClassifications) size > 0		ifFalse:			[^ self inform: 'All methods in "', self name, '"are categorized.']		ifTrue:			[self systemNavigation  browseMessageList: aList name: 'methods in "', self name, '" which have not been categorized']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/17/2005 10:48'!checkForUncommentedClasses	"Check to see if any classes involved in this change set do not have class comments.  Open up a browser showing all such classes."	| aList |	aList := self changedClasses		select:			[:aClass | aClass theNonMetaClass organization classComment isEmptyOrNil]		thenCollect:			[:aClass  | aClass theNonMetaClass name].	aList size > 0		ifFalse:			[^ self inform: 'All classes involved in this change set have class comments']		ifTrue:			[ToolSet openClassListBrowser: aList asSet asSortedArray title: 'Classes in Change Set ', self name, ': classes that lack class comments']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 4/16/2003 09:16'!checkForUncommentedMethods	| aList |	"Check to see if there are any methods in the receiver that have no comments, and open a browser on all found"	(aList := self methodsWithoutComments) size > 0		ifFalse:			[^ self inform: 'All methods in "', self name, '" have comments']		ifTrue:			[self systemNavigation  browseMessageList: aList name: 'methods in "', self name, '" that lack comments']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 4/29/2003 20:19'!checkForUnsentMessages	"Check the change set for unsent messages, and if any are found, open 	up a message-list browser on them"	| nameLine allChangedSelectors augList unsent |	nameLine := '"' , self name , '"'.	allChangedSelectors := Set new.	(augList := self changedMessageListAugmented)		do: [:each | each isValid				ifTrue: [allChangedSelectors add: each methodSymbol]].	unsent := self systemNavigation allUnSentMessagesIn: allChangedSelectors.	unsent size = 0		ifTrue: [^ self inform: 'There are no unsent messages in change set' , nameLine].	self systemNavigation		browseMessageList: (augList				select: [:each | unsent includes: each methodSymbol])		name: 'Unsent messages in ' , nameLine! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'rbb 2/18/2005 14:21'!chooseSubjectPrefixForEmail	| subjectIndex |	subjectIndex :=		(UIManager default chooseFrom: #('Bug fix [FIX]' 'Enhancement [ENH]' 'Goodie [GOODIE]' 'Test suite [TEST]' 'None of the above (will not be archived)')			title: 'What type of change set\are you submitting to the list?' withCRs).	^ #('[CS] ' '[FIX] ' '[ENH] ' '[GOODIE] ' '[TEST] ' '[CS] ') at: subjectIndex + 1! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nk 10/15/2003 09:55'!defaultChangeSetDirectory	^self class defaultChangeSetDirectory! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 8/9/2010 10:47'!fileOut	"File out the receiver, to a file whose name is a function of the  	change-set name and either of the date & time or chosen to have a  	unique numeric tag, depending on the preference  	'changeSetVersionNumbers'"	| slips nameToUse |	self checkForConversionMethods.	ChangeSet promptForDefaultChangeSetDirectoryIfNecessary.	nameToUse := Preferences changeSetVersionNumbers				ifTrue: [self defaultChangeSetDirectory nextNameFor: self name extension: FileStream cs]				ifFalse: [self name , FileDirectory dot , Utilities dateTimeSuffix, FileDirectory dot , FileStream cs].	Cursor write showWhile: [ | internalStream |			internalStream := WriteStream on: (String new: 10000).			internalStream header; timeStamp.			self fileOutPreambleOn: internalStream.			self fileOutOn: internalStream.			self fileOutPostscriptOn: internalStream.			internalStream trailer.			FileStream writeSourceCodeFrom: internalStream baseName: (nameToUse copyFrom: 1 to: nameToUse size - 3) isSt: false useHtml: false.	].	Preferences checkForSlips		ifFalse: [^ self].	slips := self checkForSlips.	(slips size > 0			and: [(UIManager default chooseFrom: #('Ignore' 'Browse slips')				 	title: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?')					= 2])		ifTrue: [self systemNavigation browseMessageList: slips name: 'Possible slips in ' , name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/28/2000 09:35'!fileOutChangesFor: class on: stream 	"Write out all the method changes for this class."	| changes |	changes := Set new.	(self methodChangesAtClass: class name) associationsDo: 		[:mAssoc | (mAssoc value = #remove or: [mAssoc value = #addedThenRemoved])			ifFalse: [changes add: mAssoc key]].	changes isEmpty ifFalse: 		[class fileOutChangedMessages: changes on: stream.		stream cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'dvf 9/27/2005 19:04'!fileOutOn: stream 	"Write out all the changes the receiver knows about"	| classList traits classes traitList list |	(self isEmpty and: [stream isKindOf: FileStream])		ifTrue: [self inform: 'Warning: no changes to file out'].			traits := self changedClasses reject: [:each | each isBehavior].	classes := self changedClasses select: [:each | each isBehavior].	traitList := self class traitsOrder: traits asOrderedCollection.	classList := self class superclassOrder: classes asOrderedCollection.	list := OrderedCollection new		addAll: traitList;		addAll: classList;		yourself.		"First put out rename, max classDef and comment changes."	list do: [:aClass | self fileOutClassDefinition: aClass on: stream].	"Then put out all the method changes"	list do: [:aClass | self fileOutChangesFor: aClass on: stream].	"Finally put out removals, final class defs and reorganization if any"	list reverseDo: [:aClass | self fileOutPSFor: aClass on: stream].	self classRemoves asSortedCollection do:		[:aClassName | stream nextChunkPut: 'Smalltalk removeClassNamed: #', aClassName; cr].! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nice 12/27/2009 03:11'!fileOutPSFor: class on: stream 	"Write out removals and initialization for this class."	| dict classRecord currentDef |	classRecord := changeRecords at: class name ifAbsent: [^ self].	dict := classRecord methodChangeTypes.	dict keysSortedSafely do:		[:key | | changeType | changeType := dict at: key.		(#(remove addedThenRemoved) includes: changeType)			ifTrue: [stream nextChunkPut: class name,						' removeSelector: ', key storeString; cr]			ifFalse: [(key = #initialize and: [class isMeta]) ifTrue:						[stream nextChunkPut: class soleInstance name, ' initialize'; cr]]].	((classRecord includesChangeType: #change)		and: [(currentDef := class definition) ~= (self fatDefForClass: class)]) ifTrue:		[stream command: 'H3'; nextChunkPut: currentDef; cr; command: '/H3'].	(classRecord includesChangeType: #reorganize) ifTrue:		[class fileOutOrganizationOn: stream.		stream cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/29/1999 13:35'!fileOutPostscriptOn: stream 	"If the receiver has a postscript, put it out onto the stream.  "	| aString |	aString := self postscriptString.	(aString ~~ nil and: [aString size > 0])		ifTrue:			[stream nextChunkPut: aString "surroundedBySingleQuotes".			stream cr; cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/29/1999 14:58'!fileOutPreambleOn: stream 	"If the receiver has a preamble, put it out onto the stream.  "	| aString |	aString := self preambleString.	(aString ~~ nil and: [aString size > 0])		ifTrue:			[stream nextChunkPut: aString "surroundedBySingleQuotes".			stream cr; cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ul 11/15/2010 11:34'!lookForSlips	"Scan the receiver for changes that the user may regard as slips to be remedied"	| slips nameLine msg |	nameLine := '"', self name, '"'.	(slips := self checkForSlips) size = 0 ifTrue:		[^ self inform: 'No slips detected in change set', nameLine].	msg := slips size = 1		ifTrue:			[ 'One method in change set', nameLine, 'has a halt, reference to the Transcript,and/or some other ''slip'' in it.Would you like to browse it? ?']		ifFalse:			[ slips size printString,' methods in change set', nameLine, 'have halts or references to theTranscript or other ''slips'' in them.Would you like to browse them?'].	(UIManager default  chooseFrom: #('Ignore' 'Browse slips') title: msg) = 2		ifTrue: [self systemNavigation  browseMessageList: slips							name: 'Possible slips in ', name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'wiz 2/12/2010 19:01'!mailOut	"Email a compressed version of this changeset to the squeak-dev list, so that it can be shared with everyone.  (You will be able to edit the email before it is sent.)"	| userName message slips |	userName := MailSender userName.	self checkForConversionMethods.	message := Cursor write showWhile: [self buildMessageForMailOutWithUser: userName].	MailSender sendMessage: message.	Preferences checkForSlips ifFalse: [^ self].	slips := self checkForSlips.	(slips size > 0 and: [self confirm: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?'])		ifTrue: [self systemNavigation browseMessageList: slips name: 'Possible slips in ' , name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/15/2005 21:27'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a path to me in the other system instead."	refStrm projectChangeSet == self ifTrue: [^ self].	"try to write reference for me"	^ DiskProxy 		global: #ChangeSet		selector: #existingOrNewChangeSetNamed: 		args: (Array with: self name)"===	refStrm replace: self with: nil.	^ nil==="! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/16/2005 18:03'!postscript	"Answer the string representing the postscript.  "	^postscript ifNotNil:[postscript isString ifTrue:[postscript] ifFalse:[postscript contents asString]]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/16/2005 18:03'!postscriptString	"Answer the string representing the postscript.  "	^self postscript! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/16/2005 18:03'!postscriptString: aString	"Establish aString as the new contents of the postscript.  "	self postscript: aString! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/16/2005 18:03'!postscript: aString	"Answer the string representing the postscript.  "	postscript := aString! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/16/2005 17:55'!preamble	"Answer the string representing the preamble"	^preamble ifNotNil:[preamble isString ifTrue:[preamble] ifFalse:[preamble contents asString]]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/16/2005 18:00'!preambleString	"Answer the string representing the preamble"	^self preamble! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/16/2005 18:00'!preambleString: aString	"Establish aString as the new contents of the preamble.  "	self preamble: aString.! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nk 7/2/2003 10:47'!preambleTemplate	"Answer a string that will form the default contents for a change set's preamble.	Just a first stab at what the content should be."	^ String streamContents: [:strm |		strm nextPutAll: '"Change Set:'.  "NOTE: fileIn recognizes preambles by this string."		strm tab;tab; nextPutAll: self name.		strm cr; nextPutAll: 'Date:'; tab; tab; tab; nextPutAll: Date today printString.		strm cr; nextPutAll: 'Author:'; tab; tab; tab; nextPutAll: Preferences defaultAuthorName.		strm cr; cr; nextPutAll: '<your descriptive text goes here>"']"ChangeSet current preambleTemplate"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/16/2005 18:00'!preamble: aString	"Establish aString as the new contents of the preamble.  "	preamble := aString! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/16/2005 18:02'!setPreambleToSay: aString	"Make aString become the preamble of this change set"	self preamble: aString! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 9/24/1999 12:33'!summaryString	"Answer the string summarizing this changeSet"	^ self summaryStringDelta: 0"To summarize all recent changeSets on a file...(FileStream newFileNamed: 'Summaries.txt') nextPutAll:	(String streamContents:		[:s | (ChangeSorter changeSetsNamedSuchThat:			[:name | name first isDigit and: [name initialIntegerOrNil >= 948]])			 do: [:cs | s nextPutAll: cs summaryString; cr]]);		closeTo list all changeSets with a certain string in the preamble...	(FileStream newFileNamed: 'MyUpdates.txt') nextPutAll:		(String streamContents:			[:s | ChangeSorter gatherChangeSetRevertables do:				[:cs | (cs preambleString notNil					and: [cs preambleString includesSubString: 'Author Name'])				 	ifTrue: [s nextPutAll: cs summaryString; cr]]]);		close"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:21'!summaryStringDelta: delta	"Answer the string summarizing this changeSet"		^ String streamContents:		[:s | | line author s2 ps intName date |		intName := self name splitInteger.		intName first isNumber			ifTrue: [s nextPutAll: (intName first + delta) printString , intName last]			ifFalse: [s nextPutAll: intName first  "weird convention of splitInteger"].		(ps := self preambleString)			ifNil: [s cr]			ifNotNil:			[s2 := ReadStream on: ps.			s2 match: 'Date:'; skipSeparators.  date := s2 nextLine.			s2 match: 'Author:'; skipSeparators.  author := s2 nextLine.			s nextPutAll: ' -- '; nextPutAll: author; nextPutAll: ' -- '; nextPutAll: date; cr.			[s2 atEnd] whileFalse:				[line := s2 nextLine.				(line isEmpty or: [line = '"']) ifFalse: [s nextPutAll: line; cr]]]].! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 1/16/2004 21:31'!verboseFileOut	"File out the receiver, to a file whose name is a function of the change-set name and either of the date & time or chosen to have a unique numeric tag, depending on the preference 'changeSetVersionNumbers'"	ChangeSet current fileOut.	Transcript cr; show: 'Changes filed out ', Date dateAndTimeNow printString! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 3/29/2000 20:42'!beIsolationSetFor: aProject	self isEmpty ifFalse: [self error: 'Must be empty at the start.'].	isolatedProject := aProject.	revertable := true.! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 4/1/2000 12:00'!clear 	"Reset the receiver to be empty.  "	changeRecords := Dictionary new.	preamble := nil.	postscript := nil! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 4/6/2001 09:40'!initialize 	"Initialize the receiver to be empty."	name ifNil:		[^ self error: 'All changeSets must be registered, as in ChangeSorter newChangeSet'].	revertable := false.	self clear.! !!ChangeSet methodsFor: 'initialize-release'!isMoribund	"Answer whether the receiver is obsolete and about to die; part of an effort to get such guys cleared out from the change sorter.  2/7/96 sw"	^ name == nil ! !!ChangeSet methodsFor: 'initialize-release' stamp: 'sw 3/6/1999 09:31'!veryDeepCopyWith: deepCopier	"Return self; this is NOT the way to launch new change sets!! Having this method here allows Change Sorters to be in parts bins"! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 3/23/2000 12:14'!wither	"The receiver is to be clobbered.  Clear it out.  2/7/96 sw"	self clear.	name := nil! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 9/21/2000 15:29'!zapHistory 	"Much stronger than trimHistory, but it should still leave the changeSet in good shape.	Must not be done on revertable changeSets		ChangeSet allInstancesDo: [:cs | cs zapHistory]."	revertable ifTrue: [^ self].  "No can do"	changeRecords do: [:chgRecord | chgRecord zapHistory]! !!ChangeSet methodsFor: 'isolation layers' stamp: 'di 3/29/2000 14:47'!invoke	"Do the first part of the invoke operation -- no particular hurry."	changeRecords do: [:changeRecord | changeRecord invokePhase1].	"Complete the invoke process -- this must be very simple."	"Replace method dicts for any method changes."	changeRecords do: [:changeRecord | changeRecord invokePhase2].	Behavior flushCache.! !!ChangeSet methodsFor: 'isolation layers' stamp: 'di 4/13/2000 12:47'!isolatedProject	"Return the isolated project for which I am the changeSet."	^ isolatedProject! !!ChangeSet methodsFor: 'isolation layers' stamp: 'di 3/29/2000 13:59'!isolationSet: setOrNil	setOrNil == self		ifTrue: [isolationSet := nil]  "Means this IS the isolation set"		ifFalse: [isolationSet := setOrNil]! !!ChangeSet methodsFor: 'isolation layers' stamp: 'di 3/29/2000 14:47'!revoke	"Do the first part of the revoke operation -- this must be very simple."	"Replace original method dicts if there are method changes."	changeRecords do: [:changeRecord | changeRecord revokePhase1].	Behavior flushCache.	"Complete the revoke process -- no particular hurry."	changeRecords do: [:changeRecord | changeRecord revokePhase2].! !!ChangeSet methodsFor: 'isolation layers' stamp: 'di 3/23/2000 12:00'!uninstall	self halt.! !!ChangeSet methodsFor: 'method changes' stamp: 'sw 12/28/2000 18:08'!adoptSelector: aSelector forClass: aClass	"Adopt the given selector/class combination as a change in the receiver"	self noteNewMethod: (aClass methodDictionary at: aSelector)			forClass: aClass selector: aSelector priorMethod: nil! !!ChangeSet methodsFor: 'method changes' stamp: 'md 8/27/2005 16:37'!atSelector: selector class: class put: changeType	selector isDoIt ifTrue: [^ self].	(self changeRecorderFor: class) atSelector: selector put: changeType.! !!ChangeSet methodsFor: 'method changes' stamp: 'nice 12/27/2009 03:11'!changedMessageList	"Used by a message set browser to access the list view information."	| messageList |	messageList := OrderedCollection new.	changeRecords associationsDo: [:clAssoc | | classNameInParts classNameInFull |		classNameInFull := clAssoc key asString.		classNameInParts := classNameInFull findTokens: ' '.		(clAssoc value allChangeTypes includes: #comment) ifTrue:			[messageList add:				(MethodReference new					setClassSymbol: classNameInParts first asSymbol					classIsMeta: false 					methodSymbol: #Comment 					stringVersion: classNameInFull, ' Comment')].		clAssoc value methodChangeTypes associationsDo: [:mAssoc |			(#(remove addedThenRemoved) includes: mAssoc value) ifFalse:				[messageList add:					(MethodReference new						setClassSymbol: classNameInParts first asSymbol						classIsMeta: classNameInParts size > 1 						methodSymbol: mAssoc key 						stringVersion: classNameInFull, ' ' , mAssoc key)]]].	^ messageList asSortedArray! !!ChangeSet methodsFor: 'method changes' stamp: 'tk 6/7/1999 18:57'!changedMessageListAugmented	"Even added classes have all messages in changedMessageList."	^ self changedMessageList asArray! !!ChangeSet methodsFor: 'method changes' stamp: 'sw 4/19/2001 19:45'!hasAnyChangeForSelector: aSelector	"Answer whether the receiver has any change under the given selector, whether it be add, change, or remove, for any class"	changeRecords do:		[:aRecord | (aRecord changedSelectors  includes: aSelector)			ifTrue:	[^ true]].	^ false! !!ChangeSet methodsFor: 'method changes' stamp: 'RAA 5/28/2001 12:05'!messageListForChangesWhich: aBlock ifNone: ifEmptyBlock	| answer |	answer := self changedMessageListAugmented select: [ :each |		aBlock value: each actualClass value: each methodSymbol	].	answer isEmpty ifTrue: [^ifEmptyBlock value].	^answer! !!ChangeSet methodsFor: 'method changes' stamp: 'di 4/1/2000 12:00'!methodChangesAtClass: className	"Return an old-style dictionary of method change types."	^(changeRecords at: className ifAbsent: [^ Dictionary new])		methodChangeTypes! !!ChangeSet methodsFor: 'method changes' stamp: 'di 4/4/2000 11:14'!removeSelectorChanges: selector class: class 	"Remove all memory of changes associated with the argument, selector, in 	this class."	| chgRecord |	(chgRecord := changeRecords at: class name ifAbsent: [^ self])		removeSelector: selector.	chgRecord hasNoChanges ifTrue: [changeRecords removeKey: class name]! !!ChangeSet methodsFor: 'method changes' stamp: 'SqR 6/13/2000 19:16'!selectorsInClass: aClassName	"Used by a ChangeSorter to access the list methods."	^ (changeRecords at: aClassName ifAbsent: [^#()]) changedSelectors! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 09:37'!absorbClass: className from: otherChangeSet	"Absorb into the receiver all the changes found in the class in the other change set.	*** Classes renamed in otherChangeSet may have problems"	| cls |	(self changeRecorderFor: className)			assimilateAllChangesIn: (otherChangeSet changeRecorderFor: className).	(cls := Smalltalk classNamed: className) ifNotNil:		[self absorbStructureOfClass: cls from: otherChangeSet].! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 3/23/2000 11:52'!absorbMethod: selector class: aClass from: aChangeSet	"Absorb into the receiver all the changes for the method in the class in the other change set."	| info |	info := aChangeSet methodChanges at: aClass name ifAbsent: [Dictionary new].	self atSelector: selector class: aClass put: (info at: selector).! !!ChangeSet methodsFor: 'moving changes' stamp: 'sw 1/30/2001 15:41'!absorbStructureOfClass: aClass from: otherChangeSet	"Absorb into the receiver all the structure and superclass info in the other change set.  Used to write conversion methods."	| sup next |	otherChangeSet structures ifNil: [^ self].	(otherChangeSet structures includesKey: aClass name) ifFalse: [^ self].	structures ifNil:		[structures := Dictionary new.		superclasses := Dictionary new].	sup := aClass name.	[(structures includesKey: sup) 		ifTrue: ["use what is here" true]		ifFalse: [self flag: #noteToDan.  "sw 1/30/2001 13:57 emergency workaround -- a case arose where the otherChangeSet's structures did not have the key, and it gummed up the works."				(otherChangeSet structures includesKey: sup) ifTrue:					[structures at: sup put: (otherChangeSet structures at: sup)].				next := otherChangeSet superclasses at: sup.				superclasses at: sup put: next.				(sup := next) = 'nil']	] whileFalse.! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 11:21'!assimilateAllChangesFoundIn: otherChangeSet	"Make all changes in otherChangeSet take effect on self as if they happened just now."	otherChangeSet changedClassNames do:		[:className | self absorbClass: className from: otherChangeSet]! !!ChangeSet methodsFor: 'moving changes' stamp: 'ar 7/16/2005 18:59'!editPreamble	"edit the receiver's preamble, in a separate window.  "	self assurePreambleExists.	UIManager default		edit: self preamble 		label: 'Preamble for ChangeSet named ', name		accept:[:aString| self preamble: aString]! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 11:49'!expungeEmptyClassChangeEntries	changeRecords keysAndValuesRemove:		[:className :classRecord | classRecord hasNoChanges]! !!ChangeSet methodsFor: 'moving changes' stamp: 'sw 4/19/2000 16:17'!expungeUniclasses	changeRecords keysAndValuesRemove:		[:className :classRecord | className endsWithDigit]! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 12:40'!forgetAllChangesFoundIn: otherChangeSet	"Remove from the receiver all method changes found in aChangeSet. The intention is facilitate the process of factoring a large set of changes into disjoint change sets.  To use:  in a change sorter, copy over all the changes you want into some new change set, then use the subtract-other-side feature to subtract those changes from the larger change set, and continue in this manner."	otherChangeSet == self ifTrue: [^ self].	otherChangeSet changedClassNames do:		[:className | self forgetChangesForClass: className in: otherChangeSet].	self expungeEmptyClassChangeEntries."  Old code...	aChangeSet changedClassNames do: 		[:className |			(cls := Smalltalk classNamed: className) ~~ nil ifTrue:				[itsMethodChanges := aChangeSet methodChanges at: className 						ifAbsent: [Dictionary new].				itsMethodChanges associationsDo: [:assoc | 					self forgetChange: assoc value forSelector: assoc key class: cls].				myClassChange := self classChangeAt: className.				myClassChange size > 0 ifTrue:					[(aChangeSet classChangeAt: className) do:						[:aChange | myClassChange remove: aChange ifAbsent: []]].				self noteClassForgotten: className]].	aChangeSet classRemoves do:		[:className | (recorder := changeRecords at: className ifAbsent: [])			ifNotNil: [recorder forgetClassRemoval]].	self expungeEmptyClassChangeEntries"! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 12:04'!forgetChangesForClass: className in: otherChangeSet	"See forgetAllChangesFoundIn:.  Used in culling changeSets."	(self changeRecorderFor: className)			forgetChangesIn: (otherChangeSet changeRecorderFor: className).	self noteClassForgotten: className! !!ChangeSet methodsFor: 'moving changes' stamp: 'sw 3/5/1999 19:27'!hasPreamble	^ preamble notNil! !!ChangeSet methodsFor: 'moving changes' stamp: 'nice 12/27/2009 03:11'!methodsWithAnyInitialsOtherThan: myInits	"Return a collection of method refs whose author appears to be different from the given one, even historically"	| slips |	slips := Set new.	self changedClasses do: [:aClass |		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc | | method |			(#(remove addedThenRemoved) includes: mAssoc value) ifFalse:				[method := aClass compiledMethodAt: mAssoc key ifAbsent: [nil].				method ifNotNil: [					(aClass changeRecordsAt: mAssoc key) do: [ :chg | | aTimeStamp |						aTimeStamp := chg stamp.						(aTimeStamp notNil and: [(aTimeStamp beginsWith: myInits) not])							ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]]].	^ slips! !!ChangeSet methodsFor: 'moving changes' stamp: 'nice 12/27/2009 03:11'!methodsWithInitialsOtherThan: myInits	"Return a collection of method refs whose author appears to be different from the given one"	| slips |	slips := OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | | aTimeStamp method | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[method := aClass compiledMethodAt: mAssoc key ifAbsent: [nil].					method ifNotNil:						[((aTimeStamp := Utilities timeStampForMethod: method) notNil and:							[(aTimeStamp beginsWith: myInits) not])								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithInitialsOtherThan: 'sw') name: 'authoring problems'"! !!ChangeSet methodsFor: 'moving changes' stamp: 'nice 10/20/2009 20:55'!methodsWithoutComments	"Return a collection representing methods in the receiver which have no precode comments"	| slips |	slips := OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[(aClass includesSelector:  mAssoc key) ifTrue:						[(aClass firstPrecodeCommentFor: mAssoc key) isEmptyOrNil								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithoutComments) name: 'methods lacking comments'"! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/1/2000 12:00'!removeClassAndMetaClassChanges: class	"Remove all memory of changes associated with this class and its metaclass.  7/18/96 sw"	changeRecords removeKey: class name ifAbsent: [].	changeRecords removeKey: class class name ifAbsent: [].! !!ChangeSet methodsFor: 'moving changes' stamp: 'yo 8/30/2002 13:59'!removeClassChanges: class	"Remove all memory of changes associated with this class"	| cname |	(class isString)		ifTrue: [ cname := class ]		ifFalse: [ cname := class name ].	changeRecords removeKey: cname ifAbsent: [].	self noteClassForgotten: cname.! !!ChangeSet methodsFor: 'moving changes' stamp: 'sw 3/5/1999 19:32'!removePreamble	preamble := nil! !!ChangeSet methodsFor: 'testing' stamp: 'RAA 10/1/2000 12:28'!belongsToAProject	Smalltalk at: #Project ifPresent:		[:projClass | projClass allProjects do:			[:proj | proj projectChangeSet == self ifTrue: [^ true]]].	^ false! !!ChangeSet methodsFor: 'testing' stamp: 'nice 10/19/2009 20:52'!containsMethodAtPosition: aFilePosition	"Answer whether the receiver contains the method logged at the given file position"	"class: aClassSymbol" "(need class parameter to speed up?)"  "<- dew 9/6/2001"	changeRecords do:		[:classChangeRecord |		classChangeRecord methodChanges do:			[:methodChangeRecord | | changeType |			changeType := methodChangeRecord changeType.			((changeType == #add or: [changeType == #change]) and:				[methodChangeRecord currentMethod notNil and: [methodChangeRecord currentMethod filePosition = aFilePosition]])					ifTrue: [^ true]]].	^ false! !!ChangeSet methodsFor: 'testing' stamp: 'RAA 11/13/2000 17:15'!correspondingProject	"If the receiver is the current change set for any project, answer it, else answer nil"	^Project allProjects 		detect: [ :proj |			proj projectChangeSet == self		]		ifNone: [nil]! !!ChangeSet methodsFor: 'testing' stamp: 'RAA 10/19/2000 13:17'!isEmpty	"Answer whether the receiver contains any elements."		changeRecords ifNil: [^true].	^ changeRecords isEmpty ! !!ChangeSet methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!methodsWithoutClassifications	"Return a collection representing methods in the receiver which have not been categorized"	| slips notClassified |	notClassified := {'as yet unclassified' asSymbol. #all}.	slips := OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | | aSelector | (aClass includesSelector:  (aSelector := mAssoc key)) ifTrue:						[(notClassified includes: (aClass organization categoryOfElement: aSelector))								ifTrue: [slips add: aClass name , ' ' , aSelector]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithoutClassifications) name: 'unclassified methods'"! !!ChangeSet methodsFor: 'testing' stamp: 'sw 8/3/1998 16:25'!okayToRemove	^ self okayToRemoveInforming: true! !!ChangeSet methodsFor: 'testing' stamp: 'sd 5/23/2003 14:24'!okayToRemoveInforming: aBoolean	"Answer whether it is okay to remove the receiver.  If aBoolean is true, inform the receiver if it is not okay"	| aName |	aName := self name.	self == self class current ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '"because it is the current change set.'].		^ false].	self belongsToAProject ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '" because it belongs to a project.'].			^ false].	^ true! !!ChangeSet methodsFor: 'testing' stamp: 'RAA 9/27/2000 22:40'!projectsBelongedTo	"Answer a list of all the projects for which the receiver is the current change set"	^ Project allProjects select: [:proj | proj projectChangeSet == self]! !!ChangeSet methodsFor: 'private' stamp: 'di 3/23/2000 08:37'!addCoherency: className	"SqR!! 19980923: If I recreate the class then don't remove it"	(self changeRecorderFor: className)		checkCoherence."	classRemoves remove: className ifAbsent: [].	(classChanges includesKey: className) ifTrue:		[(classChanges at: className) remove: #remove ifAbsent: []]"! !!ChangeSet methodsFor: 'private' stamp: 'di 3/28/2000 14:40'!atClass: class add: changeType	(self changeRecorderFor: class)		noteChangeType: changeType fromClass: class! !!ChangeSet methodsFor: 'private' stamp: 'di 4/1/2000 12:00'!atClass: class includes: changeType	^(changeRecords at: class name ifAbsent: [^false])		includesChangeType: changeType! !!ChangeSet methodsFor: 'private' stamp: 'di 4/1/2000 12:00'!atSelector: selector class: class	^ (changeRecords at: class name ifAbsent: [^ #none])		atSelector: selector ifAbsent: [^ #none]! !!ChangeSet methodsFor: 'private'!changed: anAspectSymbol with: aParameter 	"Allow objects to depend on the ChangeSet class instead of a particular instance 	of ChangeSet (which may be switched using projects)."	ChangeSet changed: anAspectSymbol with: aParameter.	super changed: anAspectSymbol with: aParameter! !!ChangeSet methodsFor: 'private' stamp: 'yo 8/30/2002 13:59'!changeRecorderFor: class	| cname |	(class isString)		ifTrue: [ cname := class ]		ifFalse: [ cname := class name ].	"Later this will init the changeRecords so according to whether they should be revertable."	^ changeRecords at: cname			ifAbsent: [^ changeRecords at: cname							put: (ClassChangeRecord new initFor: cname revertable: revertable)]! !!ChangeSet methodsFor: 'private' stamp: 'tk 3/7/2001 14:06'!fileOutClassDefinition: class on: stream 	"Write out class definition for the given class on the given stream, if the class definition was added or changed."	(self atClass: class includes: #rename) ifTrue:		[stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].	(self atClass: class includes: #change) ifTrue: [ "fat definition only needed for changes"		stream command: 'H3'; nextChunkPut: (self fatDefForClass: class); cr; command: '/H3'.		DeepCopier new checkClass: class.	"If veryDeepCopy weakly copies some inst 			vars in this class, warn author when new ones are added." 	] ifFalse: [		(self atClass: class includes: #add) ifTrue: [ "use current definition for add"			stream command: 'H3'; nextChunkPut: class definition; cr; command: '/H3'.			DeepCopier new checkClass: class.	"If veryDeepCopy weakly copies some inst 				vars in this class, warn author when new ones are added." 		].	].	(self atClass: class includes: #comment) ifTrue:		[class theNonMetaClass organization putCommentOnFile: stream numbered: 0 moveSource: false forClass: class theNonMetaClass.		stream cr].! !!ChangeSet methodsFor: 'private' stamp: 'di 4/1/2000 12:00'!oldNameFor: class	^ (changeRecords at: class name) priorName! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ChangeSet class	instanceVariableNames: 'current'!!ChangeSet class methodsFor: 'class initialization' stamp: 'ar 7/15/2005 21:12'!initialize	"ChangeSet initialize"	AllChangeSets == nil ifTrue:		[AllChangeSets := OrderedCollection new].	self gatherChangeSets.	FileServices registerFileReader: self.! !!ChangeSet class methodsFor: 'current changeset' stamp: 'ar 7/17/2005 10:48'!browseChangedMessages	"Create and schedule a message browser on each method that has been 	changed."	current isEmpty ifTrue: [^ self inform: 'There are no changed messagesin the current change set.'].	ToolSet openChangedMessageSet: current.! !!ChangeSet class methodsFor: 'current changeset' stamp: 'ar 2/26/2010 23:01'!cleanUp: aggressive	"Only delete change sets when being aggressive"	aggressive ifTrue:[		ChangeSet  removeChangeSetsNamedSuchThat:			[:cs| cs name ~= ChangeSet current name].		ChangeSet current clear.		ChangeSet current name: 'Unnamed1'.	].! !!ChangeSet class methodsFor: 'current changeset' stamp: 'wiz 9/19/2006 03:21'!current	"return the current changeset	assure first that we have a named changeset. To cure mantis #4535. "	current isMoribund		ifTrue: [(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed'))] .	^ current! !!ChangeSet class methodsFor: 'current changeset' stamp: 'em 3/31/2005 11:48'!currentChangeSetString	"ChangeSet current currentChangeSetString"	^ 'Current Change Set: ' translated, self current name! !!ChangeSet class methodsFor: 'current changeset' stamp: 'ar 11/12/2009 01:08'!newChanges: aChangeSet 	"Set the system ChangeSet to be the argument, aChangeSet.  Tell the current project that aChangeSet is now its change set.  When called from Project enter:, the setChangeSet: call is redundant but harmless; when called from code that changes the current-change-set from within a project, it's vital"	SystemChangeNotifier uniqueInstance noMoreNotificationsFor: current.	current := aChangeSet.	SystemChangeNotifier uniqueInstance notify: aChangeSet ofAllSystemChangesUsing: #event:.	Smalltalk currentProjectDo:[:proj |		proj setChangeSet: aChangeSet]! !!ChangeSet class methodsFor: 'current changeset' stamp: 'sd 5/22/2003 22:18'!noChanges 	"Initialize the system ChangeSet."	current initialize! !!ChangeSet class methodsFor: 'current changeset' stamp: 'sd 9/8/2006 21:05'!resetCurrentToNewUnnamedChangeSet 	current := self new.  	self newChanges: current ! !!ChangeSet class methodsFor: 'defaults' stamp: 'nk 7/18/2004 16:13'!defaultChangeSetDirectory	"Answer the directory in which to store ChangeSets. 	Answer the default directory if the preferred directory doesn't exist."	| dir directoryName |	directoryName := Preferences				parameterAt: #defaultChangeSetDirectoryName				ifAbsentPut: [''].	dir := directoryName isEmptyOrNil		ifTrue: [ FileDirectory default ]		ifFalse: [ FileDirectory default directoryNamed: directoryName ].	dir exists		ifTrue: [^ dir].	^ FileDirectory default! !!ChangeSet class methodsFor: 'defaults' stamp: 'nk 3/24/2004 15:52'!defaultChangeSetDirectory: dirOrName 	"Set the Preference for storing change sets to the given directory or name (possibly relative).	Rewrite directory names below the default directory as relative names.	If dirOrName is an empty string, use the default directory."	"ChangeSet defaultChangeSetDirectory: 'changeSets'"	| dirName defaultFullName |	dirName := dirOrName isString				ifTrue: [FileDirectory default fullNameFor: dirOrName]				ifFalse: [dirOrName fullName].	defaultFullName := FileDirectory default fullName.	dirName = defaultFullName		ifTrue: [dirName := '']		ifFalse: [(dirName beginsWith: defaultFullName , FileDirectory slash)				ifTrue: [dirName := dirName copyFrom: defaultFullName size + 2 to: dirName size]].	Preferences setParameter: #defaultChangeSetDirectoryName to: dirName! !!ChangeSet class methodsFor: 'defaults' stamp: 'dgd 9/6/2003 19:56'!defaultName	^ self uniqueNameLike: 'Unnamed' translated! !!ChangeSet class methodsFor: 'defaults' stamp: 'ar 8/6/2009 18:17'!promptForDefaultChangeSetDirectoryIfNecessary	"Check the Preference (if any), and prompt the user to change it if necessary.	The default if the Preference is unset is the current directory.	Answer the directory."	"ChangeSet promptForDefaultChangeSetDirectoryIfNecessary"	| choice directoryName dir |	directoryName := Preferences				parameterAt: #defaultChangeSetDirectoryName				ifAbsentPut: [''].	[dir := FileDirectory default directoryNamed: directoryName.	dir exists]		whileFalse: [choice := UIManager default chooseFrom: {			'Create directory' translated.			'Use default directory and forget preference' translated.			'Choose another directory'  translated		} title: ('The preferred change set directory (''{1}'') does not exist.Create it or use the default directory ({2})?' translated format: { directoryName. FileDirectory default pathName }).			choice = 1				ifTrue: [dir assureExistence ].			choice = 3				ifTrue: [dir := UIManager default chooseDirectory.					directoryName := dir					ifNil: [ '' ]						ifNotNil: [dir pathName ]]].		self defaultChangeSetDirectory: directoryName.		^dir! !!ChangeSet class methodsFor: 'defaults' stamp: 'ar 7/15/2005 21:24'!uniqueNameLike: aString	| try |	(self named: aString) ifNil: [^ aString].	1 to: 999999 do:		[:i | try := aString , i printString.		(self named: try) ifNil: [^ try]]! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:20'!allChangeSetNames	^ self allChangeSets collect: [:c | c name]! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:10'!allChangeSets	"Return the list of all current ChangeSets"	^ AllChangeSets! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:22'!allChangeSetsWithClass: class selector: selector	class ifNil: [^ #()].	^ self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none]! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:17'!allChangeSets: aCollection	"Return the list of all current ChangeSets"	AllChangeSets := aCollection.! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:14'!basicNewChangeSet: newName	| newSet |	newName ifNil: [^ nil].	(self named: newName) ifNotNil:		[self inform: 'Sorry that name is already used'.		^ nil].	newSet := self basicNewNamed: newName.	AllChangeSets add: newSet.	^ newSet! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:11'!changeSetsNamedSuchThat: nameBlock	"(ChangeSet changeSetsNamedSuchThat:		[:name | name first isDigit and: [name initialInteger >= 373]])		do: [:cs | AllChangeSets remove: cs wither]"	^ AllChangeSets select: [:aChangeSet | nameBlock value: aChangeSet name]! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:26'!changeSet: aChangeSet containsClass: aClass	| theClass |	theClass := Smalltalk classNamed: aClass.	theClass ifNil: [^ false].	^ aChangeSet containsClass: theClass! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:26'!deleteChangeSetsNumberedLowerThan: anInteger	"Delete all changes sets whose names start with integers smaller than anInteger"	self removeChangeSetsNamedSuchThat:		[:aName | aName first isDigit and: [aName initialIntegerOrNil < anInteger]].	"ChangeSet deleteChangeSetsNumberedLowerThan: (ChangeSorterPlus highestNumberedChangeSet name initialIntegerOrNil - 500)"! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:24'!existingOrNewChangeSetNamed: aName	| newSet |	^(self named: aName) ifNil: [		newSet := self basicNewNamed: aName.		AllChangeSets add: newSet.		newSet	]! !!ChangeSet class methodsFor: 'enumerating' stamp: 'nice 12/27/2009 03:11'!gatherChangeSets		"ChangeSet gatherChangeSets"	"Collect any change sets created in other projects"	| allChangeSets |	allChangeSets := AllChangeSets asSet.	ChangeSet allSubInstances do: [:each | | obsolete |		(allChangeSets includes: each) == (obsolete := each isMoribund) ifTrue:[			obsolete				ifTrue: ["Was included and is obsolete."						AllChangeSets remove: each]				ifFalse: ["Was not included and is not obsolete."						AllChangeSets add: each]]].	^ AllChangeSets! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:20'!highestNumberedChangeSet	"ChangeSorter highestNumberedChangeSet"	| aList |	aList := (self allChangeSetNames select: [:aString | aString startsWithDigit] thenCollect:		[:aString | aString initialIntegerOrNil]).	^ (aList size > 0)		ifTrue:			[aList max]		ifFalse:			[nil]! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:29'!mostRecentChangeSetWithChangeForClass: class selector: selector	| hits |	hits := self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ 'not in any change set'].	^ 'recent cs: ', hits last name! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:11'!named: aName	"Return the change set of the given name, or nil if none found.  1/22/96 sw"	^ AllChangeSets			detect: [:aChangeSet | aChangeSet name = aName]			ifNone: [nil]! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:13'!promoteToTop: aChangeSet	"Make aChangeSet the first in the list from now on"	AllChangeSets remove: aChangeSet ifAbsent: [^ self].	AllChangeSets add: aChangeSet! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:26'!removeChangeSetsNamedSuchThat: nameBlock	(self changeSetsNamedSuchThat: nameBlock)		do: [:cs | self removeChangeSet: cs]! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:13'!removeChangeSet: aChangeSet	"Remove the given changeSet.  Caller must assure that it's cool to do this"	AllChangeSets remove: aChangeSet ifAbsent: [].	aChangeSet wither! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:26'!removeEmptyUnnamedChangeSets	"Remove all change sets that are empty, whose names start with Unnamed,		and which are not nailed down by belonging to a Project."	"ChangeSorter removeEmptyUnnamedChangeSets"	| toGo |	(toGo := (self changeSetsNamedSuchThat: [:csName | csName beginsWith: 'Unnamed'])		select: [:cs | cs isEmpty and: [cs okayToRemoveInforming: false]])		do: [:cs | self removeChangeSet: cs].	self inform: toGo size printString, ' change set(s) removed.'! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:13'!secondaryChangeSet	"Answer a likely change set to use as the second initial one in a Dual Change Sorter.  "	AllChangeSets size = 1 ifTrue: [^ AllChangeSets first].	AllChangeSets last == ChangeSet current		ifTrue: 	[^ AllChangeSets at: (AllChangeSets size - 1)]		ifFalse:	[^ AllChangeSets last]! !!ChangeSet class methodsFor: 'file list services' stamp: 'ar 7/15/2005 21:36'!fileReaderServicesForFile: fullName suffix: suffix	^ (FileStream isSourceFileSuffix: suffix)		ifTrue: [ self services]		ifFalse: [#()]! !!ChangeSet class methodsFor: 'file list services' stamp: 'ar 7/15/2005 21:35'!serviceFileIntoNewChangeSet	"Answer a service for installing a file into a new change set"	^ SimpleServiceEntry 		provider: self 		label: 'install into new change set'		selector: #fileIntoNewChangeSet:		description: 'install the file as a body of code in the image: create a new change set and file-in the selected file into it'		buttonLabel: 'install'! !!ChangeSet class methodsFor: 'file list services' stamp: 'ar 7/15/2005 21:36'!services	^ Array with: self serviceFileIntoNewChangeSet! !!ChangeSet class methodsFor: 'fileIn/Out' stamp: 'ar 12/20/2009 13:04'!doWeFileOut: aClass given: aSet cache: cache	| aClassAllSuperclasses aClassSoleInstanceAllSuperclasses |	aClassAllSuperclasses := cache at: aClass ifAbsentPut:[		aClass allSuperclasses asArray, aClass allTraits.	].	(aSet includesAnyOf: aClassAllSuperclasses) ifTrue: [^false].	aClass isMeta ifFalse: [^true].	(aSet includes: aClass soleInstance) ifTrue: [^false].	aClassSoleInstanceAllSuperclasses := cache at: aClass soleInstance		ifAbsentPut: [aClass soleInstance allSuperclasses asArray, aClass soleInstance allTraits].	(aSet includesAnyOf: aClassSoleInstanceAllSuperclasses) ifTrue: [^false].	^true! !!ChangeSet class methodsFor: 'fileIn/Out' stamp: 'al 7/18/2004 18:45'!traitsOrder: aCollection 	"Answer an OrderedCollection. The traits 	are ordered so they can be filed in."	|  traits |	traits := aCollection asSortedCollection: [:t1 :t2 |		(t1 isBaseTrait and: [t1 classTrait == t2]) or: [			(t2 traitComposition allTraits includes: t1) or: [				(t1 traitComposition allTraits includes: t2) not]]].	^traits asArray! !!ChangeSet class methodsFor: 'instance creation' stamp: 'di 4/6/2001 09:43'!basicNewNamed: aName	^ (self basicNew name: aName) initialize! !!ChangeSet class methodsFor: 'instance creation' stamp: 'ar 7/16/2005 15:17'!new	"All current changeSets must be registered in the AllChangeSets collection.	Due to a quirk of history, this is maintained as class variable of ChangeSorter."	^ self basicNewChangeSet: ChangeSet defaultName! !!ChangeSet class methodsFor: 'scanning' stamp: 'ar 7/16/2005 19:22'!getRecentLocatorWithPrompt: aPrompt	"Prompt with a menu of how far back to go.  Return nil if user backs out.  Otherwise return the number of characters back from the end of the .changes file the user wishes to include"	 "ChangeList getRecentPosition"	| end changesFile banners positions pos chunk i |	changesFile := (SourceFiles at: 2) readOnlyCopy.	banners := OrderedCollection new.	positions := OrderedCollection new.	end := changesFile size.	pos := SmalltalkImage current lastQuitLogPosition.	[pos = 0 or: [banners size > 20]] whileFalse:		[changesFile position: pos.		chunk := changesFile nextChunk.		i := chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.		i > 0 ifTrue: [positions addLast: pos.					banners addLast: (chunk copyFrom: 5 to: i-2).					pos := Number readFrom: (chunk copyFrom: i+13 to: chunk size)]			ifFalse: [pos := 0]].	changesFile close.	pos := UIManager default chooseFrom: banners values: positions title: aPrompt.	pos == nil ifTrue: [^ nil].	^ end - pos! !!ChangeSet class methodsFor: 'scanning' stamp: 'ar 7/16/2005 15:12'!scanCategory: file	"Scan anything that involves more than one chunk; method name is historical only"	| itemPosition item tokens stamp isComment anIndex |	itemPosition := file position.	item := file nextChunk.	isComment := (item includesSubString: 'commentStamp:').	(isComment or: [item includesSubString: 'methodsFor:']) ifFalse:		["Maybe a preamble, but not one we recognize; bail out with the preamble trick"		^{(ChangeRecord new file: file position: itemPosition type: #preamble)}].	tokens := Scanner new scanTokens: item.	tokens size >= 3 ifTrue:		[stamp := ''.		anIndex := tokens indexOf: #stamp: ifAbsent: [nil].		anIndex ifNotNil: [stamp := tokens at: (anIndex + 1)].		tokens second == #methodsFor:			ifTrue: [^ self scanFile: file category: tokens third class: tokens first							meta: false stamp: stamp].		tokens third == #methodsFor:			ifTrue: [^ self scanFile: file category: tokens fourth class: tokens first							meta: true stamp: stamp]].		tokens second == #commentStamp:			ifTrue:				[stamp := tokens third.				item := (ChangeRecord new file: file position: file position type: #classComment										class: tokens first category: nil meta: false stamp: stamp).				file nextChunk.				file skipStyleChunk.				^Array with: item].	^#()! !!ChangeSet class methodsFor: 'scanning' stamp: 'ar 7/16/2005 15:11'!scanFile: file category: cat class: class meta: meta stamp: stamp	| itemPosition method items |	items := OrderedCollection new.	[itemPosition := file position.	method := file nextChunk.	file skipStyleChunk.	method size > 0] whileTrue:[		items add: (ChangeRecord new file: file position: itemPosition type: #method							class: class category: cat meta: meta stamp: stamp)].	^items! !!ChangeSet class methodsFor: 'scanning' stamp: 'ul 6/17/2011 12:25'!scanFile: file from: startPosition to: stopPosition	| changeList |	changeList := OrderedCollection new.	file position: startPosition.'Scanning ', file localName, '...'	displayProgressFrom: startPosition to: stopPosition	during: [:bar | | itemPosition item prevChar |	[file position < stopPosition] whileTrue:[		bar value: file position.		[file atEnd not and: [file peek isSeparator]]			whileTrue: [prevChar := file next].		(file peekFor: $!!) ifTrue:[			(prevChar = Character cr or: [prevChar = Character lf])				ifTrue: [changeList addAll: (self scanCategory: file)].		] ifFalse:[			itemPosition := file position.			item := file nextChunk.			file skipStyleChunk.			item size > 0 ifTrue:[				changeList add: (ChangeRecord new file: file position: itemPosition type: #doIt).			].		].	]].	^changeList! !!ChangeSet class methodsFor: 'scanning' stamp: 'ul 11/15/2010 11:34'!scanVersionsOf: method class: class meta: meta category: cat selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp changeList file |	changeList := OrderedCollection new.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:[:x | x ifNotNil:[x readOnlyCopy]].	method fileIndex = 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil] whileTrue:[		preamble := method getPreambleFrom: file at: (0 max: position - 3).		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := [Scanner new scanTokens: preamble] on: Error do:[#()]]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:]) ifTrue:[				(tokens at: tokens size-3) = #stamp: ifTrue:[					"New format gives change stamp and unified prior pointer"					stamp := tokens at: tokens size-2.					prevPos := tokens last.					prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.					prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos.				] ifFalse: ["Old format gives no stamp; prior pointer in two parts"					prevPos := tokens at: tokens size-2.					prevFileIndex := tokens last.				].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]			].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:]) ifTrue:[				(tokens at: tokens size-1) = #stamp: ifTrue: [					"New format gives change stamp and unified prior pointer"					stamp := tokens at: tokens size.			]		]. 		changeList add: (ChangeRecord new file: file position: position type: #method						class: class name category: cat meta: meta stamp: stamp).		position := prevPos.		prevPos notNil ifTrue:[file := sourceFilesCopy at: prevFileIndex].	].	sourceFilesCopy do: [:x | x ifNotNil:[x close]].	^changeList! !!ChangeSet class methodsFor: 'services' stamp: 'ar 7/15/2005 21:30'!assuredChangeSetNamed: aName	"Answer a change set of the given name.  If one already exists, answer that, else create a new one and answer it."	| existing |	^ (existing := self named: aName)		ifNotNil:			[existing]		ifNil:			[self basicNewChangeSet: aName]! !!ChangeSet class methodsFor: 'services' stamp: 'ar 7/15/2005 21:28'!buildAggregateChangeSet	"Establish a change-set named Aggregate which bears the union of all the changes in all the existing change-sets in the system (other than any pre-existing Aggregate).  This can be useful when wishing to discover potential conflicts between a disk-resident change-set and an image.  Formerly very useful, now some of its unique contributions have been overtaken by new features"	| aggregateChangeSet |	aggregateChangeSet := self existingOrNewChangeSetNamed: 'Aggregate'.	aggregateChangeSet clear.	self allChangeSets do:		[:aChangeSet | aChangeSet == aggregateChangeSet ifFalse:			[aggregateChangeSet assimilateAllChangesFoundIn: aChangeSet]]"ChangeSet buildAggregateChangeSet"	! !!ChangeSet class methodsFor: 'services' stamp: 'ar 7/15/2005 21:37'!countOfChangeSetsWithClass: aClass andSelector: aSelector	"Answer how many change sets record a change for the given class and selector"	^ (self allChangeSetsWithClass: aClass selector: aSelector) size! !!ChangeSet class methodsFor: 'services' stamp: 'ar 7/15/2005 21:38'!doesAnyChangeSetHaveClass: aClass andSelector: aSelector	"Answer whether any known change set bears a change for the given class and selector"	^ (self countOfChangeSetsWithClass: aClass andSelector: aSelector) > 0! !!ChangeSet class methodsFor: 'services' stamp: 'ar 7/15/2005 21:35'!fileIntoNewChangeSet: fullName	"File in all of the contents of the currently selected file, if any, into a new change set." 	| fn ff |	fullName ifNil: [^ Beeper beep].	ff := FileStream readOnlyFileNamed: (fn := GZipReadStream uncompressedFileName: fullName).	ChangeSet newChangesFromStream: ff named: (FileDirectory localNameFor: fn)! !!ChangeSet class methodsFor: 'services' stamp: 'nice 12/27/2009 03:11'!fileOutChangeSetsNamed: nameList	"File out the list of change sets whose names are provided"     "ChangeSorter fileOutChangeSetsNamed: #('New Changes' 'miscTidies-sw')"	| notFound empty infoString |	notFound := OrderedCollection new.	empty := OrderedCollection new.	nameList do:		[:aName | | aChangeSet | (aChangeSet := self named: aName)			ifNotNil:				[aChangeSet isEmpty					ifTrue:						[empty add: aName]					ifFalse:						[aChangeSet fileOut]]			ifNil:				[notFound add: aName]].	infoString := (nameList size - notFound size) printString, ' change set(s) filed out'.	notFound size > 0 ifTrue:		[infoString := infoString, '', notFound size printString, ' change set(s) not found:'.		notFound do:			[:aName | infoString := infoString, '', aName]].	empty size > 0 ifTrue:		[infoString := infoString, '', empty size printString, ' change set(s) were empty:'.		empty do:			[:aName | infoString := infoString, '', aName]].	self inform: infoString! !!ChangeSet class methodsFor: 'services' stamp: 'ar 7/15/2005 21:31'!newChangeSet	"Prompt the user for a name, and establish a new change set of	that name (if ok), making it the current changeset.  Return nil	of not ok, else return the actual changeset."	| newName newSet |	newName := UIManager default		request: 'Please name the new change set:'		initialAnswer: ChangeSet defaultName.	newName isEmptyOrNil ifTrue:		[^ nil].	newSet := self basicNewChangeSet: newName.	newSet ifNotNil:		[self  newChanges: newSet].	^ newSet! !!ChangeSet class methodsFor: 'services' stamp: 'ar 7/15/2005 21:31'!newChangeSet: aName	"Makes a new change set called aName, add author initials to try to	ensure a unique change set name."	| newName |	newName := aName , FileDirectory dot , Utilities authorInitials.	^ self basicNewChangeSet: newName! !!ChangeSet class methodsFor: 'services' stamp: 'nice 12/27/2009 03:11'!newChangesFromStream: aStream named: aName	"File in the code from the stream into a new change set whose	name is derived from aName. Leave the 'current change set'	unchanged. Return the new change set or nil on failure."	| oldChanges newName newSet |	oldChanges := ChangeSet current.	PreviousSet := oldChanges name. 		"so a Bumper update can find it"	newName := aName sansPeriodSuffix.	newSet := self basicNewChangeSet: newName.	[ | newStream |newSet ifNotNil:[		(aStream respondsTo: #converter:) ifFalse: [			newStream := MultiByteBinaryOrTextStream with: (aStream contentsOfEntireFile).			newStream reset.		] ifTrue: [			newStream := aStream.		].		self newChanges: newSet.		newStream setConverterForCode.		newStream fileInAnnouncing: 'Loading ', newName, '...'.		Transcript cr; show: 'File ', aName, ' successfully filed in to change set ', newName].	aStream close] ensure: [self newChanges: oldChanges].	PreviousSet := nil.	^ newSet! !!ChangeSet class methodsFor: 'filein/out' stamp: 'nice 12/27/2009 03:11'!superclassOrder: classes	"Arrange the classes in the collection, classes, in superclass order so the 	classes can be properly filed in. Do it in sets instead of ordered collections.	SqR 4/12/2000 22:04"	| all list inclusionSet cache |	list := classes copy. "list is indexable"	inclusionSet := list asSet. cache := Dictionary new.	all := OrderedCollection new: list size.	list size timesRepeat:		[ | aClass aClassIndex |			aClassIndex := list findFirst: [:one | one notNil and: 				[self doWeFileOut: one given: inclusionSet cache: cache]].			aClass := list at: aClassIndex.			all addLast: aClass.			inclusionSet remove: aClass.			list at: aClassIndex put: nil		].	^all! !ChangeSet initialize!