Set subclass: #Blackboard	instanceVariableNames: 'startingTrack rejectedTracks'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable3'!!Blackboard methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 14:02'!assertProblem	"place an initial problem on the board"		| startingArtist startingSong track lastFmUrl xmlResponse trackXML |		"prompt user for artist"	startingArtist := (FillInTheBlankMorph request: 'What artist would you like to start with? (enter song in next prompt)').		"restart if artist not entered"	startingArtist ifNil: [ self assertProblem ].		"prompt user for song"	startingSong := (FillInTheBlankMorph request: ('What song by ', startingArtist, ' would you like to start with?')) withBlanksTrimmed copyReplaceAll: (String space) with: '+'.		"restart if a song was not entered"	startingSong ifNil: [ self assertProblem ].		"create request url"	lastFmUrl := LastFmUrl baseUrl.	lastFmUrl params at: 'artist' put: (startingArtist withBlanksTrimmed copyReplaceAll: (String space) with: '+'); at: 'track' put: (startingSong withBlanksTrimmed copyReplaceAll: (String space) with: '+'); at: 'method' put: 'track.search'.		"get request repsonse xml"	xmlResponse := XMLDOMParser parseDocumentFrom: (HTTPClient httpGet: lastFmUrl asString).		"extract the first track (closest match to artist/track search)"	trackXML := (((xmlResponse elementAt: 'lfm') elementAt: 'results') elementAt: 'trackmatches') elementsAndContents first.		"create Track from track xml"	track := Track new.	track artist: (trackXML contentStringAt: 'artist').	track trackName: (trackXML contentStringAt: 'name').	track url: (trackXML contentStringAt: 'url').	.	startingTrack := track.! !!Blackboard methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 14:18'!initialize	rejectedTracks := Set new.	"self sortBlock: [:predecessor :successor | (predecessor priority > successor priority) ]."! !!Blackboard methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 13:35'!rejectedTracks	^ rejectedTracks! !!Blackboard methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 14:03'!reset	"reset the blackboard"	self removeAll.	rejectedTracks := Set new.! !!Blackboard methodsFor: 'as yet unclassified' stamp: 'sjh 6/11/2013 17:56'!startingTrack	^ startingTrack! !Object subclass: #BlackboardObject	instanceVariableNames: 'myBlackboard'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable3'!!BlackboardObject methodsFor: 'as yet unclassified' stamp: 'sjh 6/11/2013 13:24'!register	self myBlackboard add: self.! !!BlackboardObject methodsFor: 'as yet unclassified' stamp: 'sjh 6/11/2013 13:24'!resign	self myBlackboard remove: self.! !!BlackboardObject methodsFor: 'dependents access' stamp: 'sjh 6/11/2013 13:58'!notify	"notify dependents that I have changed"	"The operation notify has the semantics of a passive iterator, meaning that when we invoke it, we can supply an operation that we wish to perform on every depen- dent in the collection."	self changed: self.! !!BlackboardObject methodsFor: 'dependents access' stamp: 'sjh 6/11/2013 13:35'!numberOfDependents	^ self dependents size! !!BlackboardObject methodsFor: 'dependents access' stamp: 'sjh 6/11/2013 13:28'!references	^ self dependents! !!BlackboardObject methodsFor: 'accessing' stamp: 'sjh 6/13/2013 09:12'!myBlackboard	^ myBlackboard! !!BlackboardObject methodsFor: 'accessing' stamp: 'sjh 6/13/2013 09:12'!myBlackboard: anObject	myBlackboard := anObject! !BlackboardObject subclass: #Affirmation	instanceVariableNames: 'assumptionStatement assertionStatement priority'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable3'!!Affirmation methodsFor: 'as yet unclassified' stamp: 'sjh 6/10/2013 19:22'!make! !!Affirmation methodsFor: 'as yet unclassified' stamp: 'sjh 6/10/2013 19:51'!make: anObject	"can be an Assumption or Assertion"! !!Affirmation methodsFor: 'as yet unclassified' stamp: 'sjh 6/10/2013 19:55'!mostRecent	"return the most recent assumption or assertion"! !!Affirmation methodsFor: 'as yet unclassified' stamp: 'sjh 6/10/2013 19:22'!retract! !!Affirmation methodsFor: 'as yet unclassified' stamp: 'sjh 6/10/2013 19:56'!statementAt: n	"return the nth statement"! !!Affirmation methodsFor: 'accessing' stamp: 'sjh 6/10/2013 19:50'!assertionStatement	^ assertionStatement! !!Affirmation methodsFor: 'accessing' stamp: 'sjh 6/10/2013 19:50'!assertionStatement: anObject	assertionStatement := anObject! !!Affirmation methodsFor: 'accessing' stamp: 'sjh 6/10/2013 19:50'!assumptionStatement	^ assumptionStatement! !!Affirmation methodsFor: 'accessing' stamp: 'sjh 6/10/2013 19:50'!assumptionStatement: anObject	assumptionStatement := anObject! !!Affirmation methodsFor: 'accessing' stamp: 'sjh 6/13/2013 13:42'!priority	^ priority! !!Affirmation methodsFor: 'accessing' stamp: 'sjh 6/13/2013 14:26'!priority: aPriority	priority := aPriority! !Affirmation subclass: #Assumption	instanceVariableNames: 'target track creator reason'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable3'!!Assumption methodsFor: 'accessing' stamp: 'sjh 6/10/2013 19:24'!creator	^ creator! !!Assumption methodsFor: 'accessing' stamp: 'sjh 6/10/2013 19:24'!creator: anObject	creator := anObject! !!Assumption methodsFor: 'accessing' stamp: 'sjh 6/10/2013 19:24'!reason	^ reason! !!Assumption methodsFor: 'accessing' stamp: 'sjh 6/10/2013 19:24'!reason: anObject	reason := anObject! !!Assumption methodsFor: 'accessing' stamp: 'sjh 6/10/2013 19:24'!target	^ target! !!Assumption methodsFor: 'accessing' stamp: 'sjh 6/10/2013 19:24'!target: anObject	target := anObject! !!Assumption methodsFor: 'as yet unclassified' stamp: 'sjh 6/10/2013 19:49'!isRetractable	^ true! !!Assumption methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 08:49'!track	^ track! !!Assumption methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 08:49'!track: aTrack	track := aTrack.! !Assumption subclass: #Assertion	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable3'!!Assertion methodsFor: 'as yet unclassified' stamp: 'sjh 6/10/2013 19:49'!isRetractable	^ false! !Object subclass: #KnowledgeSource	instanceVariableNames: 'hasEvaluated pastAssumptions'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable3'!!KnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/11/2013 17:52'!applicability: aBlackboard	^ self subclassResponsibility! !!KnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 08:19'!evaluate: aBlackboard	^ self subclassResponsibility! !!KnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 18:11'!hasEvaluated	^ hasEvaluated ifNil:[hasEvaluated := false]! !!KnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/10/2013 20:06'!initialize	pastAssumptions := OrderedCollection new.! !!KnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/11/2013 00:57'!pastAssumptions	^ pastAssumptions! !!KnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 13:28'!priority	^ self subclassResponsibility! !!KnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/11/2013 00:57'!reset	self initialize.! !HttpUrl subclass: #LastFmUrl	instanceVariableNames: 'params'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable3'!!LastFmUrl methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 08:36'!asString	| stringValue |	stringValue := self printString.	self params associationsDo: [ :assoc | stringValue := stringValue, '&', assoc key, '=', ((assoc value) replaceAll: String space with: '+') ].	^ stringValue! !!LastFmUrl methodsFor: 'as yet unclassified' stamp: 'sjh 6/11/2013 01:47'!initialize	params := Dictionary new.! !!LastFmUrl methodsFor: 'as yet unclassified' stamp: 'sjh 6/11/2013 01:48'!params	^ params! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LastFmUrl class	instanceVariableNames: 'params'!!LastFmUrl class methodsFor: 'as yet unclassified' stamp: 'sjh 6/11/2013 11:23'!baseUrl	^ (self new privateInitializeFromText: 'http://ws.audioscrobbler.com/2.0/?api_key=5f376ba66130fc50ab78ff155b7430a7') initialize	! !Object subclass: #PhoMREController	instanceVariableNames: 'blackboard hints isSolved unableToProceed knowledgeSources solution'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable3'!!PhoMREController methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 08:16'!blackboard	^ blackboard! !!PhoMREController methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 08:16'!blackboard: aBlackboard	blackboard := aBlackboard	! !!PhoMREController methodsFor: 'as yet unclassified' stamp: 'sjh 6/10/2013 20:08'!connect	"Attach the controller to the knowledge source."! !!PhoMREController methodsFor: 'as yet unclassified' stamp: 'sjh 6/11/2013 17:49'!connect: aKnowledgeSource	"Attach the controller to the knowledge source."	self knowledgeSources add: aKnowledgeSource.! !!PhoMREController methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 13:40'!initialize	knowledgeSources := Set new.	unableToProceed := false.! !!PhoMREController methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 13:34'!isSolved	"Return true if the problem is solved."	^ self solution notNil! !!PhoMREController methodsFor: 'as yet unclassified' stamp: 'sjh 6/11/2013 17:49'!knowledgeSources	^ knowledgeSources! !!PhoMREController methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 18:51'!loop	| applicableKnowledgeSources |		applicableKnowledgeSources := SortedCollection new.	applicableKnowledgeSources sortBlock: [:predecessor :successor | (predecessor priority > successor priority) ].		knowledgeSources do: [ :knowledgeSource | (knowledgeSource applicability: (self blackboard))													ifTrue: [ applicableKnowledgeSources add: knowledgeSource ] ].		applicableKnowledgeSources size > 0		ifTrue: [	applicableKnowledgeSources first evaluate: self blackboard. ].		((self unableToProceed) or: self blackboard size = 0)			ifTrue: [ UserDialogBoxMorph inform: 'Sorry I couldn''t find a good recommendation. Maybe next time'. ]			ifFalse: [ self processNextBlackBoardObject.					 self isSolved						ifFalse: [ self loop ]. ].								.! !!PhoMREController methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 19:31'!processNextBlackBoardObject	| nextBlackboardObject |		nextBlackboardObject := self blackboard someElement. "TODO: get the BlackboardObject with highest priority"	(UserDialogBoxMorph confirm: ('Do you like ', nextBlackboardObject track trackName, ' by ', nextBlackboardObject track artist, ' ? Check it out at: ', nextBlackboardObject track url))		ifTrue:	[ solution := nextBlackboardObject.				  UserDialogBoxMorph inform: 'Great!!'. ]		ifFalse: [ self blackboard rejectedTracks add: nextBlackboardObject track url.				 self blackboard remove: nextBlackboardObject.				 self blackboard size > 0.				UserDialogBoxMorph inform: 'Okay. I''ll find another recommendation. This may take a minute... Working... '. ].! !!PhoMREController methodsFor: 'as yet unclassified' stamp: 'sjh 6/11/2013 12:43'!reset	"Restart the controller."	self initialize.! !!PhoMREController methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 13:34'!solution	^ solution! !!PhoMREController methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 13:40'!unableToProceed	^ false! !Object subclass: #RejectedTracks	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable3'!KnowledgeSource subclass: #SimilarArtistsKnowledgeSource	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable3'!!SimilarArtistsKnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 18:13'!applicability: aBlackboard	^ (aBlackboard size = 0) and: (self hasEvaluated not)! !!SimilarArtistsKnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 19:22'!evaluate: aBlackboard	"get the top three tracks for artists similar to the artist of a track already on the blackboard"	| myLastFmUrl xmlDocument sourceTrack artists resultTrackXML resultTrack assumption |		Transcript show: 'evaluating SimilarArtists'.		hasEvaluated := true.		aBlackboard isEmpty		ifTrue: [ sourceTrack := aBlackboard startingTrack ]		ifFalse: [ sourceTrack := aBlackboard someElement track ].		"create querystring"	myLastFmUrl := LastFmUrl baseUrl.	myLastFmUrl params at: 'method' put: 'artist.getSimilar'; at: 'artist' put: ((sourceTrack artist) withBlanksTrimmed copyReplaceAll: (String space) with: '+'); at: 'limit' put: '7'.		"get xml repsonse"	xmlDocument := XMLDOMParser parseDocumentFrom: (HTTPClient httpGet: myLastFmUrl asString).	"iterate over similar artists to get their top tracks"	artists := (xmlDocument elementAt: 'lfm') elementAt: 'similarartists'.	artists elementsAndContents do: [ :artist | 										myLastFmUrl := LastFmUrl baseUrl.										myLastFmUrl params at: 'method' put: 'artist.getTopTracks'; at: 'artist' put: ((artist contentStringAt: 'name') withBlanksTrimmed copyReplaceAll: (String space) with: '+'); at: 'limit' put: '1'.																				"get xml repsonse"										xmlDocument := XMLDOMParser parseDocumentFrom: (HTTPClient httpGet: myLastFmUrl asString).										resultTrackXML := ((xmlDocument elementAt: 'lfm') elementAt: 'toptracks') elementsAndContents first. 																				"create track"										resultTrack := Track new.										resultTrack artist: (artist contentStringAt: 'name').										resultTrack trackName: (resultTrackXML contentStringAt: 'name').										resultTrack url: (resultTrackXML contentStringAt: 'url').																				"add assumption to blackboard if this track has not been rejected yet"										(aBlackboard rejectedTracks contains: [ :each | each = resultTrack url])											ifFalse: [ assumption := Assumption new.													 assumption track: resultTrack.													 assumption creator: self.													 assumption reason: 'similar-artists-top-tracks'.													 assumption target: aBlackboard.													 assumption priority: self priority.													 aBlackboard add: assumption. ]. ].! !!SimilarArtistsKnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 18:17'!priority	^ 5! !KnowledgeSource subclass: #SimilarNumberListenersKnowledgeSource	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable3'!!SimilarNumberListenersKnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 18:47'!applicability: aBlackboard	^ (aBlackboard size = 48) and: (self hasEvaluated not)! !!SimilarNumberListenersKnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 19:24'!evaluate: aBlackboard	| smallestDifference currentTrackListeners startingTrackListeners bestMatchingAssumption |		Transcript show: 'evaluating SimilarNumberListeners'.		hasEvaluated := true.		startingTrackListeners := self getNumberOfListeners: aBlackboard startingTrack.		"initialize bestMatchingTrack to the first one on the blackboard"	bestMatchingAssumption := aBlackboard someElement.		"set smallest difference in number of listeners to a very large integer"	smallestDifference := LargePositiveInteger initializedInstance.		aBlackboard do: [ :aBlackboardObject | currentTrackListeners := self getNumberOfListeners: aBlackboardObject track.											(currentTrackListeners - startingTrackListeners) abs < smallestDifference												ifTrue: [ smallestDifference := (currentTrackListeners - startingTrackListeners) abs.														 bestMatchingAssumption := aBlackboardObject ]. ].		aBlackboard removeAll; add: bestMatchingAssumption.! !!SimilarNumberListenersKnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 16:08'!getNumberOfListeners: aTrack	| myLastFmUrl xmlDocument |	myLastFmUrl := LastFmUrl baseUrl.	myLastFmUrl params at: 'method' put: 'track.getInfo'; at: 'artist' put: (aTrack artist withBlanksTrimmed copyReplaceAll: (String space) with: '+'); at: 'track' put: (aTrack trackName withBlanksTrimmed copyReplaceAll: (String space) with: '+').		"get xml response"	xmlDocument := XMLDOMParser parseDocumentFrom: (HTTPClient httpGet: myLastFmUrl asString).		^ (((xmlDocument elementAt: 'lfm') elementAt: 'track') contentStringAt: 'listeners') asNumber! !!SimilarNumberListenersKnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 18:17'!priority	^ 5! !KnowledgeSource subclass: #SimilarTrackKnowledgeSource	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable3'!!SimilarTrackKnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 15:09'!applicability: aBlackboard	^ (aBlackboard startingTrack notNil) and: (self hasEvaluated not)! !!SimilarTrackKnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 19:24'!evaluate: aBlackboard	| myLastFmUrl xmlDocument sourceTrack resultTrackXML resultTrack assumption |	Transcript show: 'evaluating SimilarTrack'.	hasEvaluated := true.	aBlackboard isEmpty		ifTrue: [ sourceTrack := aBlackboard startingTrack ]		ifFalse: [ sourceTrack := aBlackboard someElement ].		"create querystring"	myLastFmUrl := LastFmUrl baseUrl.	myLastFmUrl params at: 'method' put: 'track.getSimilar'; at: 'artist' put: (sourceTrack artist withBlanksTrimmed copyReplaceAll: (String space) with: '+'); at: 'track' put: (sourceTrack trackName withBlanksTrimmed copyReplaceAll: (String space) with: '+'); at: 'limit' put: '1'.		"get xml response"	xmlDocument := XMLDOMParser parseDocumentFrom: (HTTPClient httpGet: myLastFmUrl asString).	resultTrackXML := ((xmlDocument elementAt: 'lfm') elementAt: 'similartracks') elementAt: 'track'.		"create track"	resultTrack := Track new.	resultTrack artist: ((resultTrackXML elementAt: 'artist') contentStringAt: 'name').	resultTrack trackName: (resultTrackXML contentStringAt: 'name').	resultTrack url: (resultTrackXML contentStringAt: 'url').		"add assumption to blackboard if this track has not been rejected yet"										(aBlackboard rejectedTracks contains: [ :each | each = resultTrack url])											ifFalse: [ assumption := Assumption new.													 assumption track: resultTrack.													 assumption creator: self.													 assumption reason: 'similar'.													 assumption target: aBlackboard.													 assumption priority: self priority.													 aBlackboard add: assumption. ].! !!SimilarTrackKnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 18:18'!priority	^ 10! !KnowledgeSource subclass: #TopTrackByTopFansKnowledgeSource	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable3'!!TopTrackByTopFansKnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 18:26'!applicability: aBlackboard	^ (aBlackboard size = 4) and: (self hasEvaluated not)! !!TopTrackByTopFansKnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 19:24'!evaluate: aBlackboard		| myLastFmUrl xmlDocument resultTrackXML topFans resultTrack assumption |	Transcript show: 'evaluating TopTrackByTopFans'.	hasEvaluated := true.		myLastFmUrl := LastFmUrl baseUrl.	myLastFmUrl params at: 'method' put: 'track.getTopFans'; at: 'artist' put: (aBlackboard startingTrack artist withBlanksTrimmed copyReplaceAll: (String space) with: '+'); at: 'track' put: (aBlackboard startingTrack trackName withBlanksTrimmed copyReplaceAll: (String space) with: '+'); at: 'limit' put: '5'.	Transcript show: myLastFmUrl asString.	"get xml response"	xmlDocument := XMLDOMParser parseDocumentFrom: (HTTPClient httpGet: myLastFmUrl asString).		topFans := ((xmlDocument elementAt: 'lfm') elementAt: 'topfans').	topFans elementsAndContents do: [ :fan |										myLastFmUrl := LastFmUrl baseUrl.										myLastFmUrl params at: 'method' put: 'user.getTopTracks'; at: 'user' put: (fan contentStringAt: 'name'); at: 'limit' put: '1'.										xmlDocument := XMLDOMParser parseDocumentFrom: (HTTPClient httpGet: myLastFmUrl asString).										resultTrackXML := ((xmlDocument elementAt: 'lfm') elementAt: 'toptracks') elementsAndContents first. 																				resultTrack := Track new.										resultTrack artist: ((resultTrackXML elementAt: 'artist') contentStringAt: 'name').										resultTrack trackName: (resultTrackXML contentStringAt: 'name').										resultTrack url: (resultTrackXML contentStringAt: 'url').																				(aBlackboard rejectedTracks contains: [ :each | each = resultTrack url])											ifFalse: [ assumption := Assumption new.													 assumption track: resultTrack.													 assumption creator: self.													 assumption reason: 'top-track-of-top-fan'.													 assumption target: aBlackboard.													 assumption priority: self priority.													 aBlackboard add: assumption. ]. ].! !!TopTrackByTopFansKnowledgeSource methodsFor: 'as yet unclassified' stamp: 'sjh 6/13/2013 18:45'!priority	^ 7! !Object subclass: #Track	instanceVariableNames: 'artist url trackName'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-Deliverable3'!!Track commentStamp: 'sjh 6/11/2013 17:15' prior: 0!Represents a track (song)!!Track methodsFor: 'accessing' stamp: 'sjh 6/11/2013 01:16'!artist	^ artist! !!Track methodsFor: 'accessing' stamp: 'sjh 6/11/2013 01:16'!artist: anObject	artist := anObject! !!Track methodsFor: 'accessing' stamp: 'sjh 6/11/2013 01:16'!duration	^ duration! !!Track methodsFor: 'accessing' stamp: 'sjh 6/11/2013 01:16'!duration: anObject	duration := anObject! !!Track methodsFor: 'accessing' stamp: 'sjh 6/11/2013 01:16'!name: anObject	name := anObject! !!Track methodsFor: 'accessing' stamp: 'sjh 6/11/2013 01:16'!playCount	^ playCount! !!Track methodsFor: 'accessing' stamp: 'sjh 6/11/2013 01:16'!playCount: anObject	playCount := anObject! !!Track methodsFor: 'accessing' stamp: 'sjh 6/13/2013 08:45'!trackName	^ trackName! !!Track methodsFor: 'accessing' stamp: 'sjh 6/13/2013 08:44'!trackName: anObject	trackName := anObject! !!Track methodsFor: 'accessing' stamp: 'sjh 6/11/2013 01:16'!url	^ url! !!Track methodsFor: 'accessing' stamp: 'sjh 6/11/2013 01:16'!url: anObject	url := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Track class	instanceVariableNames: ''!!Track class methodsFor: 'as yet unclassified' stamp: 'sjh 6/11/2013 17:07'!fromXML: anXMLElement	"		playCount: (anXMLElement contentStringAt:  'playcount') asNumber;		duration: (anXMLElement contentStringAt:  'duration') asNumber."	^ Track basicNew 		artist: ((anXMLElement elementAt:  'artist') contentStringAt: 'name');		name: (anXMLElement contentStringAt:  'name');		url: (Url absoluteFromText: (anXMLElement contentStringAt:  'url')).				 	! !