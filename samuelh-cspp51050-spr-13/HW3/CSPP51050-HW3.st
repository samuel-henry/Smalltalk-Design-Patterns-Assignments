Object subclass: #PhFMMHardware	instanceVariableNames: 'controlValues maxValues isRunning'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW3'!!PhFMMHardware methodsFor: 'constants' stamp: 'sjh 5/20/2013 17:45'!maxValues	"constant maximum values for controls. update here if new controls are added"	| maxValues |	maxValues := Dictionary new.	maxValues at: 'PSI' put: 200.	maxValues at: 'AMPS' put: 200.	^ maxValues! !!PhFMMHardware methodsFor: 'accessing' stamp: 'sjh 5/20/2013 00:53'!controlValues	"get the current control values with lazy initialization if not created yet"	^ controlValues ifNil:[controlValues := Dictionary new]! !!PhFMMHardware methodsFor: 'accessing' stamp: 'sjh 5/20/2013 03:35'!controlValues: someValues	"update control values with the passed in values, but make sure that each value is less than or equal to its corresponding maximum volume"	someValues associationsDo: [ :assoc | self controlValues at: (assoc key) put: (assoc value min: (self maxValues at: assoc key)). ].! !!PhFMMHardware methodsFor: 'accessing' stamp: 'sjh 5/20/2013 18:47'!isRunning	^ isRunning! !!PhFMMHardware methodsFor: 'initialize-release' stamp: 'sjh 5/20/2013 17:16'!start	isRunning := true.! !!PhFMMHardware methodsFor: 'initialize-release' stamp: 'sjh 5/20/2013 18:49'!stop	isRunning := false.! !Object subclass: #PhFMMMachineControl	instanceVariableNames: 'hardware runTime recipe'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW3'!!PhFMMMachineControl methodsFor: 'accessing' stamp: 'sjh 5/17/2013 15:07'!controlValues	"get control values from hardware layer"	^ hardware controlValues! !!PhFMMMachineControl methodsFor: 'accessing' stamp: 'sjh 5/17/2013 15:07'!controlValues: someValues	"send control values to hardware layer"	hardware controlValues: someValues.! !!PhFMMMachineControl methodsFor: 'accessing' stamp: 'sjh 5/20/2013 15:58'!hardware	"get the hardware that is controlled by this instance"	^ hardware! !!PhFMMMachineControl methodsFor: 'accessing' stamp: 'sjh 5/20/2013 15:58'!hardware: someHardware	"set the hardware this is controlled by this instance"	hardware := someHardware! !!PhFMMMachineControl methodsFor: 'accessing' stamp: 'sjh 5/20/2013 17:43'!recipe	"get the recipe associated with this machine control"	^ recipe! !!PhFMMMachineControl methodsFor: 'accessing' stamp: 'sjh 5/20/2013 17:43'!recipe: aRecipe	"set the recipe associated with this machine control"	recipe := aRecipe.! !!PhFMMMachineControl methodsFor: 'accessing' stamp: 'sjh 5/20/2013 17:44'!runTime	"get the run time for this machine control"	^ runTime! !!PhFMMMachineControl methodsFor: 'accessing' stamp: 'sjh 5/20/2013 17:44'!runTime: someTime	"set the run time for this machine control"	runTime := someTime.! !!PhFMMMachineControl methodsFor: 'execution' stamp: 'sjh 5/20/2013 17:20'!execute	| file psi amps |		"start the hardware"	self hardware start.		"run the manual parameters if no recipe was provided, else run the recipe and return whether a good part was created"	recipe isNil 		ifTrue: [ file := FileDirectory default forceNewFileNamed: 'Manual.DAS.csv'. 				"print 'MANUAL'"				file nextPutAll: 'MANUAL'; cr.								"run the manual parameters for the specified time"				1 to: runTime do: [ :elapsedTime | psi := self controlValues at: 'PSI'.												   amps := self controlValues at: 'AMPS'.												   file nextPutAll: elapsedTime asString; nextPutAll: ','; nextPutAll: psi  asString; 												         nextPutAll: ','; nextPutAll: amps asString; cr. ].				"close the filestream"				file close.								"stop the hardware"				self hardware stop.								"manual parts always return good part created"				^ true]					ifFalse: [ "create the part" 				 self recipe createPart.								"stop the hardware"				 self hardware stop.								"return whether a good part was created"				^ self isValidExecution ].! !!PhFMMMachineControl methodsFor: 'initialize-release' stamp: 'sjh 5/20/2013 15:59'!initialize	"create the underlying hardware"	hardware := PhFMMHardware new.		"initialize running time to 0"	runTime := 0.! !!PhFMMMachineControl methodsFor: 'testing' stamp: 'sjh 5/20/2013 18:16'!isValidExecution	| referenceFile referenceFileContents DASFile DASFileContents |		"get the reference and DAS files"	referenceFile := FileDirectory default readOnlyFileNamed: (self recipe recipeFileName, '.reference.csv').	DASFile := FileDirectory default readOnlyFileNamed: (self recipe recipeFileName, '.DAS.csv').		"get collections of the delimited String tokens"	referenceFileContents := referenceFile contentsOfEntireFile asString findTokens: String cr, String lf, String space, ',' asString.	DASFileContents := DASFile contentsOfEntireFile asString findTokens: String cr, String lf, String space, ',' asString.		Transcript show: DASFileContents; cr.	Transcript show: referenceFileContents; cr.		"return whether the collections' contents are equal"	^ referenceFileContents = DASFileContents! !Object subclass: #PhFMMUserInterface	instanceVariableNames: 'machineControl'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW3'!!PhFMMUserInterface methodsFor: 'accessing' stamp: 'sjh 5/20/2013 17:41'!controlValues	"get control values from lower layer"	^ machineControl controlValues.! !!PhFMMUserInterface methodsFor: 'accessing' stamp: 'sjh 5/20/2013 17:41'!controlValues: someValues	"pass control values down a layer"	machineControl controlValues: someValues.! !!PhFMMUserInterface methodsFor: 'accessing' stamp: 'sjh 5/20/2013 17:41'!machineControl	"get the machine control associated with this UI"	^ machineControl! !!PhFMMUserInterface methodsFor: 'accessing' stamp: 'sjh 5/20/2013 17:40'!machineControl: anObject	"set the machine control associated with this UI"	machineControl := anObject! !!PhFMMUserInterface methodsFor: 'execution' stamp: 'sjh 5/20/2013 17:42'!executeRecipe: aRecipe	"set the recipe to execute on the lower layer"	machineControl recipe: aRecipe.		"execute the recipe from the lower layer and return whether a good part was created"	^ machineControl execute.! !!PhFMMUserInterface methodsFor: 'execution' stamp: 'sjh 5/20/2013 18:30'!manualRunForTime: time	machineControl runTime: time.	machineControl recipe: nil.	^ machineControl execute.	! !!PhFMMUserInterface methodsFor: 'initialize-release' stamp: 'sjh 5/20/2013 17:42'!initialize	"instantiate a machine control associated with this UI"	machineControl := PhFMMMachineControl new.! !Object subclass: #Recipe	instanceVariableNames: 'machineControl recipeName mode partSize recipeFileName'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW3'!!Recipe methodsFor: 'accessing' stamp: 'sjh 5/20/2013 18:26'!machineControl	"get this recipe's back pointer to its machine control"	^ machineControl! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/20/2013 18:27'!machineControl: anObject	"set this recipe's back pointer to its machine control"	machineControl := anObject! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/20/2013 18:27'!mode	"get this recipe's mode"	^ mode! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/20/2013 18:27'!mode: anObject	"set this recipe's mode"	mode := anObject! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/20/2013 18:27'!partSize	"get this recipe's part size"	^ partSize! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/20/2013 18:28'!partSize: anObject	"set this recipe's part size"	partSize := anObject! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/20/2013 18:28'!recipeFileName	"get this recipe's file name"	^ recipeFileName! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/20/2013 18:28'!recipeFileName: anObject	"set this recipe's file name"	recipeFileName := anObject! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/20/2013 18:28'!recipeName	"get this recipe's name"	^ recipeName! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/20/2013 18:28'!recipeName: anObject	"set this recipe's name"	recipeName := anObject! !!Recipe methodsFor: 'initialize-release' stamp: 'sjh 5/20/2013 18:25'!initializeWithFile: fileName for: aMachineControl	"initialize recipe with a back pointer to the controls"	| file contents tokens |		"set the back pointer"	machineControl := aMachineControl.		"set the recipe file name"	recipeFileName := fileName.		"open recipe file"	file := (FileStream fileNamed: fileName) readOnly text.		"get its contents"	contents := file contentsOfEntireFile asString.		"get the comma-delimited String tokens"	tokens := contents findTokens: $,.		"set the recipe name"	recipeName := tokens at: 1.		"set the mode"	mode := tokens at: 2.		"set the part size"	partSize := (tokens at: 3) asNumber.! !!Recipe methodsFor: 'recipe execution' stamp: 'sjh 5/20/2013 18:26'!createPart	"concrete recipes implement strategies"	^ self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Recipe class	instanceVariableNames: ''!!Recipe class methodsFor: 'instance creation' stamp: 'sjh 5/20/2013 18:24'!fromFile: fileName for: aMachineControl	"create a recipe from a file with a back pointer to the controls"	^ self basicNew initializeWithFile: fileName for: aMachineControl! !Recipe subclass: #ConstantCurrentRecipe	instanceVariableNames: 'controlValues'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW3'!!ConstantCurrentRecipe methodsFor: 'recipe execution' stamp: 'sjh 5/20/2013 19:14'!createPart	"ConstantCurrent: T = { 0...20 }, PSI = 50 - (T * 2) where PSI can never get below 10, AMPS (constant) = part size + 50"	| outputFile |		"append .DAS.csv to recipe file name to create output file"	outputFile := FileDirectory default forceNewFileNamed: (recipeFileName, '.DAS.csv').			"set output stream to convert smalltalk carriage returns to regular carriage returns"	outputFile wantsLineEndConversion: true.		"write the header info to the output file"	outputFile nextPutAll: recipeName, ',', mode, ',', partSize.			"instantiate control values"	controlValues := Dictionary new.		"set the constant current"	controlValues at: 'AMPS' put: (self partSize + 50).		"run the recipe"	0 to: 20 do: [ :elapsedTime | 										"set the control values for this second (just update pressure)"					controlValues at: 'PSI' put: (200 min: (10 max: (50 - (elapsedTime * 2)))).																	"pass the control values to the hardware"					self machineControl controlValues: controlValues.																	"write the values at this second to the output file"					outputFile cr; nextPutAll: elapsedTime asString, ',', (machineControl controlValues at: 'PSI') asString, ',', (machineControl controlValues at: 'AMPS') asString.].		"close the filestream"								outputFile close.! !Recipe subclass: #ConstantPressureRecipe	instanceVariableNames: 'controlValues'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW3'!!ConstantPressureRecipe methodsFor: 'recipe execution' stamp: 'sjh 5/20/2013 19:15'!createPart	"ConstantPressure: T (time, in seconds) = { 0, 1,...10 }, PSI (should remain constant) = part size + 100, AMPS = T * 2"	| outputFile |	"append .DAS.csv to recipe file name to create output file"	outputFile := FileDirectory default forceNewFileNamed: (recipeFileName, '.DAS.csv').		"write the header info to the output file"	outputFile nextPutAll: recipeName, ',', mode, ',', partSize.			"set output stream to convert smalltalk carriage returns to regular carriage returns"	outputFile wantsLineEndConversion: true.		"instantiate control values"	controlValues := Dictionary new.		"set constant pressure value"	controlValues at: 'PSI' put: (partSize + 100).		"run the recipe"	0 to: 10 do: [ :elapsedTime | 											"set the control values for this second (just update current)"					controlValues at: 'AMPS' put: (elapsedTime * 2).														"pass the control values to the hardware"					self machineControl controlValues: controlValues.										"write the values at this second to the output file"					outputFile 	nextPutAll: String cr, elapsedTime asString, ',', (machineControl controlValues at: 'PSI') asString, ',', (machineControl controlValues at: 'AMPS') asString.].			"close the filestream"										outputFile close.! !Recipe subclass: #RampRecipe	instanceVariableNames: 'controlValues'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW3'!!RampRecipe methodsFor: 'recipe execution' stamp: 'sjh 5/20/2013 19:24'!createPart	"Ramp: T = { 0...30 }, PSI = ramp up from 0 to 100, in 10 PSI increments each second and then hold at 100,  AMPS = ramp up, starting from part size, in 20 AMP increments each second. Only part sizes of 50 or above can be used. If a recipe has a smaller part size, the MachineControl must generate an error. This part size restriction only applies to the Ramp recipe."	| outputFile |		"append .DAS.csv to recipe file name to create output file"	outputFile := FileDirectory default forceNewFileNamed: (recipeFileName, '.DAS.csv').		"set output stream to convert smalltalk carriage returns to regular carriage returns"	outputFile wantsLineEndConversion: true.		"write the header info to the output file"	outputFile nextPutAll: recipeName, ',', mode, ',', partSize.		"input validation. only execute the recipe if we have a valid part size. otherwise, write an error."	partSize < 50		ifTrue: [ outputFile cr; nextPutAll: 'Error: Part size must be >= 50' ]		ifFalse: [ "instantiate control values"				 controlValues := Dictionary new.								"run the recipe"				0 to: 30 do: [ :elapsedTime | controlValues at: 'PSI' put: (100 min: (elapsedTime * 10)); at: 'AMPS' put: (200 min: (50 + (elapsedTime * 20))).								 self machineControl controlValues: controlValues.								outputFile 	cr; nextPutAll: elapsedTime asString; nextPutAll: ','; 											nextPutAll: (machineControl controlValues at: 'PSI') asString; nextPutAll: ','; 											nextPutAll: (machineControl controlValues at: 'AMPS') asString.] ].		"close the filestream"							outputFile close. ! !