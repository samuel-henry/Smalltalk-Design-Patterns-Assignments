Object subclass: #PhFMMHardware	instanceVariableNames: 'controlValues maxValues isRunning'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW3'!!PhFMMHardware methodsFor: 'constants' stamp: 'sjh 5/20/2013 17:45'!maxValues	"constant maximum values for controls. update here if new controls are added"	| maxValues |	maxValues := Dictionary new.	maxValues at: 'PSI' put: 200.	maxValues at: 'AMPS' put: 200.	^ maxValues! !!PhFMMHardware methodsFor: 'accessing' stamp: 'sjh 5/20/2013 00:53'!controlValues	"get the current control values with lazy initialization if not created yet"	^ controlValues ifNil:[controlValues := Dictionary new]! !!PhFMMHardware methodsFor: 'accessing' stamp: 'sjh 5/20/2013 03:35'!controlValues: someValues	"update control values with the passed in values, but make sure that each value is less than or equal to its corresponding maximum volume"	someValues associationsDo: [ :assoc | self controlValues at: (assoc key) put: (assoc value min: (self maxValues at: assoc key)). ].! !!PhFMMHardware methodsFor: 'initialize-release' stamp: 'sjh 5/20/2013 17:16'!start	isRunning := true.! !!PhFMMHardware methodsFor: 'initialize-release' stamp: 'sjh 5/20/2013 17:16'!stop	controlValues := nil.	isRunning := false.! !Object subclass: #PhFMMMachineControl	instanceVariableNames: 'hardware runTime recipe'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW3'!!PhFMMMachineControl methodsFor: 'accessing' stamp: 'sjh 5/17/2013 15:07'!controlValues	"get control values from hardware layer"	^ hardware controlValues! !!PhFMMMachineControl methodsFor: 'accessing' stamp: 'sjh 5/17/2013 15:07'!controlValues: someValues	"send control values to hardware layer"	hardware controlValues: someValues.! !!PhFMMMachineControl methodsFor: 'accessing' stamp: 'sjh 5/20/2013 15:58'!hardware	"get the hardware that is controlled by this instance"	^ hardware! !!PhFMMMachineControl methodsFor: 'accessing' stamp: 'sjh 5/20/2013 15:58'!hardware: someHardware	"set the hardware this is controlled by this instance"	hardware := someHardware! !!PhFMMMachineControl methodsFor: 'accessing' stamp: 'sjh 5/20/2013 17:43'!recipe	"get the recipe associated with this machine control"	^ recipe! !!PhFMMMachineControl methodsFor: 'accessing' stamp: 'sjh 5/20/2013 17:43'!recipe: aRecipe	"set the recipe associated with this machine control"	recipe := aRecipe.! !!PhFMMMachineControl methodsFor: 'accessing' stamp: 'sjh 5/20/2013 17:44'!runTime	"get the run time for this machine control"	^ runTime! !!PhFMMMachineControl methodsFor: 'accessing' stamp: 'sjh 5/20/2013 17:44'!runTime: someTime	"set the run time for this machine control"	runTime := someTime.! !!PhFMMMachineControl methodsFor: 'execution' stamp: 'sjh 5/20/2013 17:20'!execute	| file psi amps |		"start the hardware"	self hardware start.		"run the manual parameters if no recipe was provided, else run the recipe and return whether a good part was created"	recipe isNil 		ifTrue: [ file := FileDirectory default forceNewFileNamed: 'Manual.DAS.csv'. 				"print 'MANUAL'"				file nextPutAll: 'MANUAL'; cr.								"run the manual parameters for the specified time"				1 to: runTime do: [ :elapsedTime | psi := self controlValues at: 'PSI'.												   amps := self controlValues at: 'AMPS'.												   file nextPutAll: elapsedTime asString; nextPutAll: ','; nextPutAll: psi  asString; 												         nextPutAll: ','; nextPutAll: amps asString; cr. ].				"close the filestream"				file close.								"stop the hardware"				self hardware stop.								"manual parts always return good part created"				^ true]					ifFalse: [ "create the part" 				 self recipe createPart.								"stop the hardware"				 self hardware stop.								"return whether a good part was created"				^ self isValidExecution ].! !!PhFMMMachineControl methodsFor: 'initialize-release' stamp: 'sjh 5/20/2013 15:59'!initialize	"create the underlying hardware"	hardware := PhFMMHardware new.		"initialize running time to 0"	runTime := 0.! !!PhFMMMachineControl methodsFor: 'testing' stamp: 'sjh 5/20/2013 15:54'!isValidExecution	| referenceFile referenceFileContents DASFile DASFileContents |		"get the reference and DAS files"	referenceFile := FileDirectory default readOnlyFileNamed: (self recipe recipeFileName, '.reference.csv').	DASFile := FileDirectory default readOnlyFileNamed: (self recipe recipeFileName, '.DAS.csv').		"get collections of the delimited String tokens"	referenceFileContents := referenceFile contentsOfEntireFile asString findTokens: String cr, String lf, String space, ',' asString.	DASFileContents := DASFile contentsOfEntireFile asString findTokens: String cr, String lf, String space, ',' asString.		"return whether the collections' contents are equal"	^ referenceFileContents = DASFileContents! !Object subclass: #PhFMMUserInterface	instanceVariableNames: 'machineControl'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW3'!!PhFMMUserInterface methodsFor: 'accessing' stamp: 'sjh 5/20/2013 17:41'!controlValues	"get control values from lower layer"	^ machineControl controlValues.! !!PhFMMUserInterface methodsFor: 'accessing' stamp: 'sjh 5/20/2013 17:41'!controlValues: someValues	"pass control values down a layer"	machineControl controlValues: someValues.! !!PhFMMUserInterface methodsFor: 'accessing' stamp: 'sjh 5/20/2013 17:41'!machineControl	"get the machine control associated with this UI"	^ machineControl! !!PhFMMUserInterface methodsFor: 'accessing' stamp: 'sjh 5/20/2013 17:40'!machineControl: anObject	"set the machine control associated with this UI"	machineControl := anObject! !!PhFMMUserInterface methodsFor: 'execution' stamp: 'sjh 5/20/2013 17:42'!executeRecipe: aRecipe	"set the recipe to execute on the lower layer"	machineControl recipe: aRecipe.		"execute the recipe from the lower layer and return whether a good part was created"	^ machineControl execute.! !!PhFMMUserInterface methodsFor: 'execution' stamp: 'sjh 5/17/2013 16:33'!manualRunFor: time	machineControl runTime: time.	machineControl recipe: nil.	machineControl execute.	! !!PhFMMUserInterface methodsFor: 'initialize-release' stamp: 'sjh 5/20/2013 17:42'!initialize	"instantiate a machine control associated with this UI"	machineControl := PhFMMMachineControl new.! !Object subclass: #Recipe	instanceVariableNames: 'machineControl recipeName mode partSize recipeFileName'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW3'!!Recipe methodsFor: 'accessing' stamp: 'sjh 5/17/2013 17:58'!machineControl	^ machineControl! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/17/2013 17:58'!machineControl: anObject	machineControl := anObject! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/17/2013 17:58'!mode	^ mode! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/17/2013 17:58'!mode: anObject	mode := anObject! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/17/2013 17:58'!partSize	^ partSize! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/17/2013 17:58'!partSize: anObject	partSize := anObject! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/19/2013 16:38'!recipeFileName	^ recipeFileName! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/19/2013 16:38'!recipeFileName: anObject	recipeFileName := anObject! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/17/2013 19:16'!recipeName	^ recipeName! !!Recipe methodsFor: 'accessing' stamp: 'sjh 5/17/2013 19:16'!recipeName: anObject	recipeName := anObject! !!Recipe methodsFor: 'initialize-release' stamp: 'sjh 5/19/2013 16:37'!initializeWithFile: fileName	| file contents tokens |	recipeFileName := fileName.	file := (FileStream fileNamed: fileName) readOnly text.	contents := file contentsOfEntireFile asString.		tokens := contents findTokens: $,.	recipeName := tokens at: 1.	mode := tokens at: 2.	partSize := (tokens at: 3) asNumber.! !!Recipe methodsFor: 'initialize-release' stamp: 'sjh 5/20/2013 00:06'!initializeWithFile: fileName for: aMachineControl	| file contents tokens |	machineControl := aMachineControl.	recipeFileName := fileName.	file := (FileStream fileNamed: fileName) readOnly text.	contents := file contentsOfEntireFile asString.		tokens := contents findTokens: $,.	recipeName := tokens at: 1.	mode := tokens at: 2.	partSize := (tokens at: 3) asNumber.! !!Recipe methodsFor: 'recipe execution' stamp: 'sjh 5/17/2013 17:58'!createPart	^ self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Recipe class	instanceVariableNames: ''!!Recipe class methodsFor: 'instance creation' stamp: 'sjh 5/17/2013 18:04'!fromFile: fileName	^ self basicNew initializeWithFile: fileName! !!Recipe class methodsFor: 'instance creation' stamp: 'sjh 5/20/2013 00:06'!fromFile: fileName for: aMachineControl	^ self basicNew initializeWithFile: fileName for: aMachineControl! !Recipe subclass: #ConstantCurrentRecipe	instanceVariableNames: 'controlValues'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW3'!!ConstantCurrentRecipe methodsFor: 'recipe execution' stamp: 'sjh 5/20/2013 17:23'!createPart	"ConstantCurrent: T = { 0...20 }, PSI = 50 - (T * 2) where PSI can never get below 10, AMPS (constant) = part size + 50"	| outputFile amps |		"append .DAS.csv to recipe file name to create output file"	outputFile := FileDirectory default forceNewFileNamed: (recipeFileName, '.DAS.csv').			"set output stream to convert smalltalk carriage returns to regular carriage returns"	outputFile wantsLineEndConversion: true.		"instantiate control values"	controlValues := Dictionary new.		amps := self partSize + 50.	outputFile nextPutAll: recipeName, ',', mode, ',', partSize.		"run the recipe"	0 to: 20 do: [ :elapsedTime | 										"set the control values for this second"					controlValues at: 'PSI' put: (200 min: (10 max: (50 - (elapsedTime * 2)))); at: 'AMPS' put: amps.																	"pass the control values to the hardware"					self machineControl controlValues: controlValues.																	"print the values at this second to the output file"					outputFile cr; nextPutAll: elapsedTime asString, ',', (machineControl controlValues at: 'PSI') asString, ',', (machineControl controlValues at: 'AMPS') asString.].		"close the filestream"								outputFile close.! !Recipe subclass: #ConstantPressureRecipe	instanceVariableNames: 'controlValues'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW3'!!ConstantPressureRecipe methodsFor: 'recipe execution' stamp: 'sjh 5/20/2013 14:41'!createPart	"ConstantPressure: T (time, in seconds) = { 0, 1,...10 }, PSI (should remain constant) = part size + 100, AMPS = T * 2"	| outputFile psi |	"append .DAS.csv to recipe file name to create output file"	outputFile := FileDirectory default forceNewFileNamed: (recipeFileName, '.DAS.csv').		"set output stream to convert smalltalk carriage returns to regular carriage returns"	outputFile wantsLineEndConversion: true.		"set constant pressure value"	psi := partSize + 100.		"instantiate control values"	controlValues := Dictionary new.		outputFile nextPutAll: recipeName, ',', mode, ',', partSize.	0 to: 10 do: [ :elapsedTime | controlValues at: 'PSI' put: psi; at: 'AMPS' put: (elapsedTime * 2).								 self machineControl controlValues: controlValues.								 outputFile 	nextPutAll: String cr, elapsedTime asString, ',', (machineControl controlValues at: 'PSI') asString, ',', (machineControl controlValues at: 'AMPS') asString.].												outputFile close.! !Recipe subclass: #RampRecipe	instanceVariableNames: 'controlValues'	classVariableNames: ''	poolDictionaries: ''	category: 'CSPP51050-HW3'!!RampRecipe methodsFor: 'recipe execution' stamp: 'sjh 5/20/2013 14:41'!createPart	"Ramp: T = { 0...30 }, PSI = ramp up from 0 to 100, in 10 PSI increments each second and then hold at 100,  AMPS = ramp up, starting from part size, in 20 AMP increments each second. Only part sizes of 50 or above can be used. If a recipe has a smaller part size, the MachineControl must generate an error. This part size restriction only applies to the Ramp recipe."	| outputFile |		"input validation"	partSize < 50		ifTrue: [ self error: 'Part size must be >= 50' ].			"append .DAS.csv to recipe file name to create output file"	outputFile := FileDirectory default forceNewFileNamed: (recipeFileName, '.DAS.csv').		"set output stream to convert smalltalk carriage returns to regular carriage returns"	outputFile wantsLineEndConversion: true.		"instantiate control values"	controlValues := Dictionary new.		outputFile nextPutAll: recipeName, ',', mode, ',', partSize.				0 to: 30 do: [ :elapsedTime | 	controlValues at: 'PSI' put: (100 min: (elapsedTime * 10)); at: 'AMPS' put: (200 min: (50 + (elapsedTime * 20))).												self machineControl controlValues: controlValues.												outputFile 	cr; nextPutAll: elapsedTime asString; nextPutAll: ','; 															nextPutAll: (machineControl controlValues at: 'PSI') asString; nextPutAll: ','; 															nextPutAll: (machineControl controlValues at: 'AMPS') asString.].	outputFile close.! !